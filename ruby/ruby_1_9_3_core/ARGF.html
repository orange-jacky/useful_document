<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
  <!-- classpage -- >
    <!-- RD version: 0.22.9  -->
  <meta content="text/html; charset=UTF-8" http-equiv="Content-Type" />
  <meta content="2013-05-18 11:09:36 -0700" http-equiv="change-date" />
    
  <!-- rel_prefix = ''   asset_rel_prefix = ''  --> 
  <title>Class: ARGF (Ruby 1.9.3) </title>
  <!-- link rel="stylesheet" href="css/obf.css"  -->
  <link rel="stylesheet" href="/css/inuit.css" >
  <link rel="stylesheet" href="/css/grid.inuit.css" >
  <link rel="stylesheet" href="/css/2011.css" type="text/css" >
  <link rel="stylesheet" href="/css/rdoc.css" type="text/css" >

  <script src="/js/jquery.js" type="text/javascript" charset="utf-8"></script>
  <script src="/js/thickbox-compressed.js" type="text/javascript" charset="utf-8"></script>
  <script src="/js/quicksearch.js" type="text/javascript" charset="utf-8"></script>
  <script src="/js/rubydoc.js" type="text/javascript" charset="utf-8"></script> 

 
<script src="/js/highlight.min.js"></script>
<script> 
  hljs.tabReplace = '  ';
  hljs.initHighlightingOnLoad();
  </script> 

  <style type='text/css'>

    #vulns-alert #vulns{
      background-color: #c33 ! important;
      width: 100%;
      text-align: center;
   }
   
   #vulns-alert #vulns a {
    color: #F99 ! important;
   }
 </style>

</head>

<body id="top" class="class rdocstar">
<div id='actionbar' >
<div class='wrapper'>
  <ul class='grids g0'>
	<li class='grid-2' ><a href='/' target='_top' >Home</a></li>
	<li class='grid-2' ><a href='/core-1.9.3' target='_top' >Core 1.9.3</a></li>
	<li class='grid-2' ><a href='/stdlib-1.9.3' target='_top' >Std-lib 1.9.3</a></li>
	<li class='grid-2' ><a href='/gems' target='_top' >Gems</a></li>
	<li class='grid-2' ><a href='/downloads' target='_top' >Downloads</a></li>
	<li class='grid-5 right' id='rd-action-search'><form id="searchbox_011815814100681837392:wnccv6st5qk" action="http://ruby-doc.com/search.html"><input type="hidden" name="cx" value="011815814100681837392:wnccv6st5qk" ><input  id='rd-search-input' name="q" type="text" size="20" >&#160;&#160;<input type="submit" name="sa" value="Search" ><input type="hidden" name="cof" value="FORID:9" ></form>
</li>
</ul>
</div>
<span id='vulns-alert'></span>
</div> <!-- end action bar -->
 <div class='wrapper'>
  <div id="metadata">
    <div id="home-metadata">
      <div id="home-section" class="section">
        <h3 class="section-header">
          <a href="/index.html">Home</a>
          <a href="/index.html#classes">Classes</a>
          <a href="/index.html#methods">Methods</a>
          
          
          <!-- br><a id='alternateFormatLink' class='rotate' href="#" onclick='matchingYardUrl()'>YARD version</a -->
          
        </h3>
      </div>
    </div>

    <div id="file-metadata">
      <div id="file-list-section" class="section">
        <h3 class="section-header">In Files</h3>
        <div class="section-body">
          <ul id='file-metadata'>

          
          
          
          <li class='in-file'>io.c</li>      
            
          </ul>
        </div>
      </div>

      
    </div>

    <div id="class-metadata">
      
      <!-- Parent Class -->
      <div id="parent-class-section" class="section">
        <h3 class="section-header">Parent</h3>
        
        <p class="link"><a href="Object.html">Object</a></p>
        
      </div>
      

      

      

      
      <!-- Method Quickref -->
      <div id="method-list-section" class="section">
        <h3 class="section-header">Methods</h3>
        <ul class="link-list">
          
          <li><a href="#method-i-argv">#argv</a></li>
          
          <li><a href="#method-i-binmode">#binmode</a></li>
          
          <li><a href="#method-i-binmode-3F">#binmode?</a></li>
          
          <li><a href="#method-i-bytes">#bytes</a></li>
          
          <li><a href="#method-i-chars">#chars</a></li>
          
          <li><a href="#method-i-close">#close</a></li>
          
          <li><a href="#method-i-closed-3F">#closed?</a></li>
          
          <li><a href="#method-i-codepoints">#codepoints</a></li>
          
          <li><a href="#method-i-each">#each</a></li>
          
          <li><a href="#method-i-each_byte">#each_byte</a></li>
          
          <li><a href="#method-i-each_char">#each_char</a></li>
          
          <li><a href="#method-i-each_codepoint">#each_codepoint</a></li>
          
          <li><a href="#method-i-each_line">#each_line</a></li>
          
          <li><a href="#method-i-eof">#eof</a></li>
          
          <li><a href="#method-i-eof-3F">#eof?</a></li>
          
          <li><a href="#method-i-external_encoding">#external_encoding</a></li>
          
          <li><a href="#method-i-file">#file</a></li>
          
          <li><a href="#method-i-filename">#filename</a></li>
          
          <li><a href="#method-i-fileno">#fileno</a></li>
          
          <li><a href="#method-i-getbyte">#getbyte</a></li>
          
          <li><a href="#method-i-getc">#getc</a></li>
          
          <li><a href="#method-i-gets">#gets</a></li>
          
          <li><a href="#method-i-inplace_mode">#inplace_mode</a></li>
          
          <li><a href="#method-i-inplace_mode-3D">#inplace_mode=</a></li>
          
          <li><a href="#method-i-internal_encoding">#internal_encoding</a></li>
          
          <li><a href="#method-i-lineno">#lineno</a></li>
          
          <li><a href="#method-i-lineno-3D">#lineno=</a></li>
          
          <li><a href="#method-i-lines">#lines</a></li>
          
          <li><a href="#method-i-path">#path</a></li>
          
          <li><a href="#method-i-pos">#pos</a></li>
          
          <li><a href="#method-i-pos-3D">#pos=</a></li>
          
          <li><a href="#method-i-print">#print</a></li>
          
          <li><a href="#method-i-printf">#printf</a></li>
          
          <li><a href="#method-i-putc">#putc</a></li>
          
          <li><a href="#method-i-puts">#puts</a></li>
          
          <li><a href="#method-i-read">#read</a></li>
          
          <li><a href="#method-i-read_nonblock">#read_nonblock</a></li>
          
          <li><a href="#method-i-readbyte">#readbyte</a></li>
          
          <li><a href="#method-i-readchar">#readchar</a></li>
          
          <li><a href="#method-i-readline">#readline</a></li>
          
          <li><a href="#method-i-readlines">#readlines</a></li>
          
          <li><a href="#method-i-readpartial">#readpartial</a></li>
          
          <li><a href="#method-i-rewind">#rewind</a></li>
          
          <li><a href="#method-i-seek">#seek</a></li>
          
          <li><a href="#method-i-set_encoding">#set_encoding</a></li>
          
          <li><a href="#method-i-skip">#skip</a></li>
          
          <li><a href="#method-i-tell">#tell</a></li>
          
          <li><a href="#method-i-to_a">#to_a</a></li>
          
          <li><a href="#method-i-to_i">#to_i</a></li>
          
          <li><a href="#method-i-to_io">#to_io</a></li>
          
          <li><a href="#method-i-to_s">#to_s</a></li>
          
          <li><a href="#method-i-to_write_io">#to_write_io</a></li>
          
          <li><a href="#method-i-write">#write</a></li>
          
        </ul>
      </div>
      

      
      <!-- Included Modules -->
      <div id="includes-section" class="section">
        <h3 class="section-header">Included Modules</h3>
        <ul class="link-list">
        
        
          <li><a class="include" href="Enumerable.html">Enumerable</a></li>
        
        
        </ul>
      </div>
      
    </div>

    <div id="project-metadata">
      
      
      <div id="fileindex-section" class="section project-section">
        <h3 class="section-header">Files</h3>
        <ul id='files'>
        
          
          <li class="file"><a href="_lib/xmlrpc/README_rdoc.html">README.rdoc</a></li>
        
          
          <li class="file"><a href="_test/rdoc/test_ja_large_rdoc.html">test.ja.large.rdoc</a></li>
        
          
          <li class="file"><a href="_test/rdoc/test_ja_rdoc.html">test.ja.rdoc</a></li>
        
          
          <li class="file"><a href="doc/rake/command_line_usage_rdoc.html">command_line_usage.rdoc</a></li>
        
          
          <li class="file"><a href="doc/rake/glossary_rdoc.html">glossary.rdoc</a></li>
        
          
          <li class="file"><a href="doc/rake/proto_rake_rdoc.html">proto_rake.rdoc</a></li>
        
          
          <li class="file"><a href="doc/rake/rakefile_rdoc.html">rakefile.rdoc</a></li>
        
          
          <li class="file"><a href="doc/rake/rational_rdoc.html">rational.rdoc</a></li>
        
          
          <li class="file"><a href="doc/rake/release_notes/rake-0_8_7_rdoc.html">rake-0.8.7.rdoc</a></li>
        
          
          <li class="file"><a href="doc/re_rdoc.html">re.rdoc</a></li>
        
        </ul>
      </div>
      

      <div id="classindex-section" class="section project-section">
        <h3 class="section-header">Class/Module Index
          <span class="search-toggle"><img src="/images/find.png"
            height="16" width="16" alt="[+]"
            title="show/hide quicksearch" /></span></h3>
        <form action="#" method="get" accept-charset="utf-8" class="initially-hidden">
        <fieldset>
          <legend>Quicksearch</legend>
          <input type="text" name="quicksearch" value=""
            class="quicksearch-field" />
        </fieldset>
        </form>

        <ul class="link-list">
          
          
          
          <li><a href="ARGF.html">ARGF</a></li>
        
          
          
          <li><a href="ArgumentError.html">ArgumentError</a></li>
        
          
          
          <li><a href="Array.html">Array</a></li>
        
          
          
          <li><a href="BasicObject.html">BasicObject</a></li>
        
          
          
          <li><a href="Bignum.html">Bignum</a></li>
        
          
          
          <li><a href="Binding.html">Binding</a></li>
        
          
          
          <li><a href="Class.html">Class</a></li>
        
          
          
          <li><a href="Comparable.html">Comparable</a></li>
        
          
          
          <li><a href="Complex.html">Complex</a></li>
        
          
          
          <li><a href="Continuation.html">Continuation</a></li>
        
          
          
          <li><a href="Data.html">Data</a></li>
        
          
          
          <li><a href="Dir.html">Dir</a></li>
        
          
          
          <li><a href="ENV.html">ENV</a></li>
        
          
          
          <li><a href="EOFError.html">EOFError</a></li>
        
          
          
          <li><a href="Encoding.html">Encoding</a></li>
        
          
          
          <li><a href="Encoding/CompatibilityError.html">Encoding::CompatibilityError</a></li>
        
          
          
          <li><a href="Encoding/Converter.html">Encoding::Converter</a></li>
        
          
          
          <li><a href="Encoding/ConverterNotFoundError.html">Encoding::ConverterNotFoundError</a></li>
        
          
          
          <li><a href="Encoding/InvalidByteSequenceError.html">Encoding::InvalidByteSequenceError</a></li>
        
          
          
          <li><a href="Encoding/UndefinedConversionError.html">Encoding::UndefinedConversionError</a></li>
        
          
          
          <li><a href="EncodingError.html">EncodingError</a></li>
        
          
          
          <li><a href="Enumerable.html">Enumerable</a></li>
        
          
          
          <li><a href="Enumerator.html">Enumerator</a></li>
        
          
          
          <li><a href="Enumerator/Generator.html">Enumerator::Generator</a></li>
        
          
          
          <li><a href="Enumerator/Yielder.html">Enumerator::Yielder</a></li>
        
          
          
          <li><a href="Errno.html">Errno</a></li>
        
          
          
          <li><a href="Exception.html">Exception</a></li>
        
          
          
          <li><a href="FalseClass.html">FalseClass</a></li>
        
          
          
          <li><a href="Fiber.html">Fiber</a></li>
        
          
          
          <li><a href="FiberError.html">FiberError</a></li>
        
          
          
          <li><a href="File.html">File</a></li>
        
          
          
          <li><a href="File/Constants.html">File::Constants</a></li>
        
          
          
          <li><a href="File/Stat.html">File::Stat</a></li>
        
          
          
          <li><a href="FileTest.html">FileTest</a></li>
        
          
          
          <li><a href="Fixnum.html">Fixnum</a></li>
        
          
          
          <li><a href="Float.html">Float</a></li>
        
          
          
          <li><a href="FloatDomainError.html">FloatDomainError</a></li>
        
          
          
          <li><a href="GC.html">GC</a></li>
        
          
          
          <li><a href="GC/Profiler.html">GC::Profiler</a></li>
        
          
          
          <li><a href="Hash.html">Hash</a></li>
        
          
          
          <li><a href="IO.html">IO</a></li>
        
          
          
          <li><a href="IO/WaitReadable.html">IO::WaitReadable</a></li>
        
          
          
          <li><a href="IO/WaitWritable.html">IO::WaitWritable</a></li>
        
          
          
          <li><a href="IOError.html">IOError</a></li>
        
          
          
          <li><a href="IndexError.html">IndexError</a></li>
        
          
          
          <li><a href="Integer.html">Integer</a></li>
        
          
          
          <li><a href="Interrupt.html">Interrupt</a></li>
        
          
          
          <li><a href="Kernel.html">Kernel</a></li>
        
          
          
          <li><a href="KeyError.html">KeyError</a></li>
        
          
          
          <li><a href="LoadError.html">LoadError</a></li>
        
          
          
          <li><a href="LocalJumpError.html">LocalJumpError</a></li>
        
          
          
          <li><a href="Marshal.html">Marshal</a></li>
        
          
          
          <li><a href="MatchData.html">MatchData</a></li>
        
          
          
          <li><a href="Math.html">Math</a></li>
        
          
          
          <li><a href="Math/DomainError.html">Math::DomainError</a></li>
        
          
          
          <li><a href="Method.html">Method</a></li>
        
          
          
          <li><a href="Module.html">Module</a></li>
        
          
          
          <li><a href="Mutex.html">Mutex</a></li>
        
          
          
          <li><a href="NameError.html">NameError</a></li>
        
          
          
          <li><a href="NilClass.html">NilClass</a></li>
        
          
          
          <li><a href="NoMemoryError.html">NoMemoryError</a></li>
        
          
          
          <li><a href="NoMethodError.html">NoMethodError</a></li>
        
          
          
          <li><a href="NotImplementedError.html">NotImplementedError</a></li>
        
          
          
          <li><a href="Numeric.html">Numeric</a></li>
        
          
          
          <li><a href="Object.html">Object</a></li>
        
          
          
          <li><a href="ObjectSpace.html">ObjectSpace</a></li>
        
          
          
          <li><a href="Proc.html">Proc</a></li>
        
          
          
          <li><a href="Process.html">Process</a></li>
        
          
          
          <li><a href="Process/GID.html">Process::GID</a></li>
        
          
          
          <li><a href="Process/Status.html">Process::Status</a></li>
        
          
          
          <li><a href="Process/Sys.html">Process::Sys</a></li>
        
          
          
          <li><a href="Process/UID.html">Process::UID</a></li>
        
          
          
          <li><a href="Random.html">Random</a></li>
        
          
          
          <li><a href="Range.html">Range</a></li>
        
          
          
          <li><a href="RangeError.html">RangeError</a></li>
        
          
          
          <li><a href="Rational.html">Rational</a></li>
        
          
          
          <li><a href="Regexp.html">Regexp</a></li>
        
          
          
          <li><a href="RegexpError.html">RegexpError</a></li>
        
          
          
          <li><a href="RubyVM.html">RubyVM</a></li>
        
          
          
          <li><a href="RubyVM/Env.html">RubyVM::Env</a></li>
        
          
          
          <li><a href="RubyVM/InstructionSequence.html">RubyVM::InstructionSequence</a></li>
        
          
          
          <li><a href="RuntimeError.html">RuntimeError</a></li>
        
          
          
          <li><a href="ScriptError.html">ScriptError</a></li>
        
          
          
          <li><a href="SecurityError.html">SecurityError</a></li>
        
          
          
          <li><a href="Signal.html">Signal</a></li>
        
          
          
          <li><a href="SignalException.html">SignalException</a></li>
        
          
          
          <li><a href="StandardError.html">StandardError</a></li>
        
          
          
          <li><a href="StopIteration.html">StopIteration</a></li>
        
          
          
          <li><a href="String.html">String</a></li>
        
          
          
          <li><a href="Struct.html">Struct</a></li>
        
          
          
          <li><a href="Symbol.html">Symbol</a></li>
        
          
          
          <li><a href="SyntaxError.html">SyntaxError</a></li>
        
          
          
          <li><a href="SystemCallError.html">SystemCallError</a></li>
        
          
          
          <li><a href="SystemExit.html">SystemExit</a></li>
        
          
          
          <li><a href="SystemStackError.html">SystemStackError</a></li>
        
          
          
          <li><a href="Thread.html">Thread</a></li>
        
          
          
          <li><a href="ThreadError.html">ThreadError</a></li>
        
          
          
          <li><a href="ThreadGroup.html">ThreadGroup</a></li>
        
          
          
          <li><a href="Time.html">Time</a></li>
        
          
          
          <li><a href="TrueClass.html">TrueClass</a></li>
        
          
          
          <li><a href="TypeError.html">TypeError</a></li>
        
          
          
          <li><a href="UnboundMethod.html">UnboundMethod</a></li>
        
          
          
          <li><a href="ZeroDivisionError.html">ZeroDivisionError</a></li>
        
          
          
          <li><a href="fatal.html">fatal</a></li>
        
          
          
          <li><a href="unknown.html">unknown</a></li>
        
        </ul>
        <div id="no-class-search-results" style="display: none;">No matching classes.</div>
      </div>

      
    </div>
  </div> <!-- metadata -->
  <div class='adzbox'  id="azk83167">
   <div id="carbonads-container"><div class="carbonad"><div id="azcarbon"></div><script type="text/javascript">var z = document.createElement("script"); z.type = "text/javascript"; z.async = true; z.src = "http://engine.carbonads.com/z/19647/azcarbon_2_1_0_VERT"; var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(z, s);</script></div></div>

  </div> 
  <div id="documentation">
    <h1 class="class">ARGF</h1>

    <div id="description" class="description">
      
<p><code>ARGF</code> is a stream designed for use in scripts that process
files given as command-line arguments or passed in via STDIN.</p>

<p>The arguments passed to your script are stored in the <code>ARGV</code> <a
href="Array.html">Array</a>, one argument per element. <code>ARGF</code>
assumes that any arguments that aren't filenames have been removed from
<code>ARGV</code>. For example:</p>

<pre class="ruby">$ <span class="ruby-identifier">ruby</span> <span class="ruby-identifier">argf</span>.<span class="ruby-identifier">rb</span> <span class="ruby-operator">-</span><span class="ruby-operator">-</span><span class="ruby-identifier">verbose</span> <span class="ruby-identifier">file1</span> <span class="ruby-identifier">file2</span>

<span class="ruby-constant">ARGV</span>  <span class="ruby-comment">#=&gt; [&quot;--verbose&quot;, &quot;file1&quot;, &quot;file2&quot;]</span>
<span class="ruby-identifier">option</span> = <span class="ruby-constant">ARGV</span>.<span class="ruby-identifier">shift</span> <span class="ruby-comment">#=&gt; &quot;--verbose&quot;</span>
<span class="ruby-constant">ARGV</span>  <span class="ruby-comment">#=&gt; [&quot;file1&quot;, &quot;file2&quot;]</span>
</pre>

<p>You can now use <code>ARGF</code> to work with a concatenation of each of
these named files. For instance, <code>ARGF.read</code> will return the
contents of <em>file1</em> followed by the contents of <em>file2</em>.</p>

<p>After a file in <code>ARGV</code> has been read <code>ARGF</code> removes
it from the <a href="Array.html">Array</a>. Thus, after all files have been
read <code>ARGV</code> will be empty.</p>

<p>You can manipulate <code>ARGV</code> yourself to control what
<code>ARGF</code> operates on. If you remove a file from <code>ARGV</code>,
it is ignored by <code>ARGF</code>; if you add files to <code>ARGV</code>,
they are treated as if they were named on the command line. For example:</p>

<pre class="ruby"><span class="ruby-constant">ARGV</span>.<span class="ruby-identifier">replace</span> [<span class="ruby-string">&quot;file1&quot;</span>]
<span class="ruby-constant">ARGF</span>.<span class="ruby-identifier">readlines</span> <span class="ruby-comment"># Returns the contents of file1 as an Array</span>
<span class="ruby-constant">ARGV</span>           <span class="ruby-comment">#=&gt; []</span>
<span class="ruby-constant">ARGV</span>.<span class="ruby-identifier">replace</span> [<span class="ruby-string">&quot;file2&quot;</span>, <span class="ruby-string">&quot;file3&quot;</span>]
<span class="ruby-constant">ARGF</span>.<span class="ruby-identifier">read</span>      <span class="ruby-comment"># Returns the contents of file2 and file3</span>
</pre>

<p>If <code>ARGV</code> is empty, <code>ARGF</code> acts as if it contained
STDIN, i.e. the data piped to your script. For example:</p>

<pre>$ echo &quot;glark&quot; | ruby -e 'p ARGF.read'
&quot;glark\n&quot;</pre>

    </div><!-- description -->

    
    
    
    <div id="5Buntitled-5D" class="documentation-section">
      

      

      

      

      <!-- Methods -->
      
      <div id="public-instance-method-details" class="method-section section">
        <h3 class="section-header">Public Instance Methods</h3>

      
        <div id="argv-method" class="method-detail ">
          <a name="method-i-argv"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">argv  &rarr; ARGV</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Returns the <code>ARGV</code> array, which contains the arguments passed to
your script, one per element.</p>

<p>For example:</p>

<pre class="ruby">$ <span class="ruby-identifier">ruby</span> <span class="ruby-identifier">argf</span>.<span class="ruby-identifier">rb</span> <span class="ruby-operator">-</span><span class="ruby-identifier">v</span> <span class="ruby-identifier">glark</span>.<span class="ruby-identifier">txt</span>

<span class="ruby-constant">ARGF</span>.<span class="ruby-identifier">argv</span>   <span class="ruby-comment">#=&gt; [&quot;-v&quot;, &quot;glark.txt&quot;]</span>
</pre>
            

            
            <div class="method-source-code" id="argv-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
argf_argv(VALUE argf)
{
    return ARGF.argv;
}
            </pre> 
            </div><!-- argv-source -->
            
          </div>

          

          
        </div><!-- argv-method -->
      
        <div id="binmode-method" class="method-detail ">
          <a name="method-i-binmode"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">binmode  &rarr; ARGF</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Puts <code>ARGF</code> into binary mode. Once a stream is in binary mode,
it cannot be reset to non-binary mode. This option has the following
effects:</p>
<ul><li>
<p>Newline conversion is disabled.</p>
</li><li>
<p><a href="Encoding.html">Encoding</a> conversion is disabled.</p>
</li><li>
<p>Content is treated as ASCII-8BIT.</p>
</li></ul>
            

            
            <div class="method-source-code" id="binmode-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
argf_binmode_m(VALUE argf)
{
    ARGF.binmode = 1;
    next_argv();
    ARGF_FORWARD(0, 0);
    rb_io_ascii8bit_binmode(ARGF.current_file);
    return argf;
}
            </pre> 
            </div><!-- binmode-source -->
            
          </div>

          

          
        </div><!-- binmode-method -->
      
        <div id="binmode-3F-method" class="method-detail ">
          <a name="method-i-binmode-3F"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">binmode?  &rarr; true or false</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <pre>Returns true if +ARGF+ is being read in binary mode; false otherwise. (To
enable binary mode use +ARGF.binmode+.</pre>

<p>For example:</p>

<pre class="ruby"><span class="ruby-constant">ARGF</span>.<span class="ruby-identifier">binmode?</span>  <span class="ruby-comment">#=&gt; false</span>
<span class="ruby-constant">ARGF</span>.<span class="ruby-identifier">binmode</span>
<span class="ruby-constant">ARGF</span>.<span class="ruby-identifier">binmode?</span>  <span class="ruby-comment">#=&gt; true</span>
</pre>
            

            
            <div class="method-source-code" id="binmode-3F-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
argf_binmode_p(VALUE argf)
{
    return ARGF.binmode ? Qtrue : Qfalse;
}
            </pre> 
            </div><!-- binmode-3F-source -->
            
          </div>

          

          
        </div><!-- binmode-3F-method -->
      
        <div id="bytes-method" class="method-detail ">
          <a name="method-i-bytes"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">bytes     {|byte| block }  &rarr; ARGF</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">bytes                      &rarr; an_enumerator</span>
            
          </div>
          
          
          <div>
  
            
            <pre>Iterates over each byte of each file in +ARGV+.
A byte is returned as a +Fixnum+ in the range 0..255.

This method allows you to treat the files supplied on the command line as
a single file consisting of the concatenation of each named file. After
the last byte of the first file has been returned, the first byte of the
second file is returned. The +ARGF.filename+ method can be used to
determine the filename of the current byte.

If no block is given, an enumerator is returned instead.</pre>

<p>For example:</p>

<pre class="ruby"><span class="ruby-constant">ARGF</span>.<span class="ruby-identifier">bytes</span>.<span class="ruby-identifier">to_a</span>  <span class="ruby-comment">#=&gt; [35, 32, ... 95, 10]</span>
</pre>
            

            
            <div class="method-source-code" id="bytes-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
argf_each_byte(VALUE argf)
{
    RETURN_ENUMERATOR(argf, 0, 0);
    for (;;) {
        if (!next_argv()) return argf;
        rb_block_call(ARGF.current_file, rb_intern(&quot;each_byte&quot;), 0, 0, 0, 0);
        ARGF.next_p = 1;
    }
}
            </pre> 
            </div><!-- bytes-source -->
            
          </div>

          

          
        </div><!-- bytes-method -->
      
        <div id="chars-method" class="method-detail ">
          <a name="method-i-chars"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">chars      {|char| block }  &rarr; ARGF</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">chars                       &rarr; an_enumerator</span>
            
          </div>
          
          
          <div>
  
            
            <p>Iterates over each character of each file in <code>ARGF</code>.</p>

<p>This method allows you to treat the files supplied on the command line as a
single file consisting of the concatenation of each named file. After the
last character of the first file has been returned, the first character of
the second file is returned. The <code>ARGF.filename</code> method can be
used to determine the name of the file in which the current character
appears.</p>

<p>If no block is given, an enumerator is returned instead.</p>
            

            
            <div class="method-source-code" id="chars-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
argf_each_char(VALUE argf)
{
    RETURN_ENUMERATOR(argf, 0, 0);
    for (;;) {
        if (!next_argv()) return argf;
        rb_block_call(ARGF.current_file, rb_intern(&quot;each_char&quot;), 0, 0, 0, 0);
        ARGF.next_p = 1;
    }
}
            </pre> 
            </div><!-- chars-source -->
            
          </div>

          

          
        </div><!-- chars-method -->
      
        <div id="close-method" class="method-detail ">
          <a name="method-i-close"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">close  &rarr; ARGF</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <pre>Closes the current file and skips to the next in the stream. Trying to
close a file that has already been closed causes an +IOError+ to be
raised.</pre>

<p>For example:</p>

<pre class="ruby">$ <span class="ruby-identifier">ruby</span> <span class="ruby-identifier">argf</span>.<span class="ruby-identifier">rb</span> <span class="ruby-identifier">foo</span> <span class="ruby-identifier">bar</span>

<span class="ruby-constant">ARGF</span>.<span class="ruby-identifier">filename</span>  <span class="ruby-comment">#=&gt; &quot;foo&quot;</span>
<span class="ruby-constant">ARGF</span>.<span class="ruby-identifier">close</span>
<span class="ruby-constant">ARGF</span>.<span class="ruby-identifier">filename</span>  <span class="ruby-comment">#=&gt; &quot;bar&quot;</span>
<span class="ruby-constant">ARGF</span>.<span class="ruby-identifier">close</span>
<span class="ruby-constant">ARGF</span>.<span class="ruby-identifier">close</span>     <span class="ruby-comment">#=&gt; closed stream (IOError)</span>
</pre>
            

            
            <div class="method-source-code" id="close-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
argf_close_m(VALUE argf)
{
    next_argv();
    argf_close(ARGF.current_file);
    if (ARGF.next_p != -1) {
        ARGF.next_p = 1;
    }
    ARGF.lineno = 0;
    return argf;
}
            </pre> 
            </div><!-- close-source -->
            
          </div>

          

          
        </div><!-- close-method -->
      
        <div id="closed-3F-method" class="method-detail ">
          <a name="method-i-closed-3F"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">closed?  &rarr; true or false</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Returns <em>true</em> if the current file has been closed; <em>false</em>
otherwise. Use <code>ARGF.close</code> to actually close the current file.</p>
            

            
            <div class="method-source-code" id="closed-3F-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
argf_closed(VALUE argf)
{
    next_argv();
    ARGF_FORWARD(0, 0);
    return rb_io_closed(ARGF.current_file);
}
            </pre> 
            </div><!-- closed-3F-source -->
            
          </div>

          

          
        </div><!-- closed-3F-method -->
      
        <div id="codepoints-method" class="method-detail ">
          <a name="method-i-codepoints"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">codepoints      {|codepoint| block }  &rarr; ARGF</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">codepoints                       &rarr; an_enumerator</span>
            
          </div>
          
          
          <div>
  
            
            <p>Iterates over each codepoint of each file in <code>ARGF</code>.</p>

<p>This method allows you to treat the files supplied on the command line as a
single file consisting of the concatenation of each named file. After the
last codepoint of the first file has been returned, the first codepoint of
the second file is returned. The <code>ARGF.filename</code> method can be
used to determine the name of the file in which the current codepoint
appears.</p>

<p>If no block is given, an enumerator is returned instead.</p>
            

            
            <div class="method-source-code" id="codepoints-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
argf_each_codepoint(VALUE argf)
{
    RETURN_ENUMERATOR(argf, 0, 0);
    for (;;) {
        if (!next_argv()) return argf;
        rb_block_call(ARGF.current_file, rb_intern(&quot;each_codepoint&quot;), 0, 0, 0, 0);
        ARGF.next_p = 1;
    }
}
            </pre> 
            </div><!-- codepoints-source -->
            
          </div>

          

          
        </div><!-- codepoints-method -->
      
        <div id="each-method" class="method-detail ">
          <a name="method-i-each"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">each(sep=$/)            {|line| block }  &rarr; ARGF</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">each(sep=$/,limit)      {|line| block }  &rarr; ARGF</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">each(...)                                &rarr; an_enumerator</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">each_line(sep=$/)       {|line| block }  &rarr; ARGF</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">each_line(sep=$/,limit) {|line| block }  &rarr; ARGF</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">each_line(...)                           &rarr; an_enumerator</span>
            
          </div>
          
          
          <div>
  
            
            <p>Returns an enumerator which iterates over each line (separated by
<em>sep</em>, which defaults to your platform’s newline character) of each
file in <code>ARGV</code>. If a block is supplied, each line in turn will
be yielded to the block, otherwise an enumerator is returned. The optional
<em>limit</em> argument is a <code>Fixnum</code> specifying the maximum
length of each line; longer lines will be split according to this limit.</p>

<p>This method allows you to treat the files supplied on the command line as a
single file consisting of the concatenation of each named file. After the
last line of the first file has been returned, the first line of the second
file is returned. The <code>ARGF.filename</code> and
<code>ARGF.lineno</code> methods can be used to determine the filename and
line number, respectively, of the current line.</p>

<p>For example, the following code prints out each line of each named file
prefixed with its line number, displaying the filename once per file:</p>

<pre class="ruby"><span class="ruby-constant">ARGF</span>.<span class="ruby-identifier">lines</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">line</span><span class="ruby-operator">|</span>
  <span class="ruby-identifier">puts</span> <span class="ruby-constant">ARGF</span>.<span class="ruby-identifier">filename</span> <span class="ruby-keyword">if</span> <span class="ruby-constant">ARGF</span>.<span class="ruby-identifier">lineno</span> <span class="ruby-operator">==</span> <span class="ruby-value">1</span>
  <span class="ruby-identifier">puts</span> <span class="ruby-node">&quot;#{ARGF.lineno}: #{line}&quot;</span>
<span class="ruby-keyword">end</span>
</pre>
            

            
            <div class="method-source-code" id="each-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
argf_each_line(int argc, VALUE *argv, VALUE argf)
{
    RETURN_ENUMERATOR(argf, argc, argv);
    for (;;) {
        if (!next_argv()) return argf;
        rb_block_call(ARGF.current_file, rb_intern(&quot;each_line&quot;), argc, argv, 0, 0);
        ARGF.next_p = 1;
    }
}
            </pre> 
            </div><!-- each-source -->
            
          </div>

          

          
        </div><!-- each-method -->
      
        <div id="each_byte-method" class="method-detail ">
          <a name="method-i-each_byte"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">each_byte {|byte| block }  &rarr; ARGF</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">each_byte                  &rarr; an_enumerator</span>
            
          </div>
          
          
          <div>
  
            
            <pre>Iterates over each byte of each file in +ARGV+.
A byte is returned as a +Fixnum+ in the range 0..255.

This method allows you to treat the files supplied on the command line as
a single file consisting of the concatenation of each named file. After
the last byte of the first file has been returned, the first byte of the
second file is returned. The +ARGF.filename+ method can be used to
determine the filename of the current byte.

If no block is given, an enumerator is returned instead.</pre>

<p>For example:</p>

<pre class="ruby"><span class="ruby-constant">ARGF</span>.<span class="ruby-identifier">bytes</span>.<span class="ruby-identifier">to_a</span>  <span class="ruby-comment">#=&gt; [35, 32, ... 95, 10]</span>
</pre>
            

            
            <div class="method-source-code" id="each_byte-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
argf_each_byte(VALUE argf)
{
    RETURN_ENUMERATOR(argf, 0, 0);
    for (;;) {
        if (!next_argv()) return argf;
        rb_block_call(ARGF.current_file, rb_intern(&quot;each_byte&quot;), 0, 0, 0, 0);
        ARGF.next_p = 1;
    }
}
            </pre> 
            </div><!-- each_byte-source -->
            
          </div>

          

          
        </div><!-- each_byte-method -->
      
        <div id="each_char-method" class="method-detail ">
          <a name="method-i-each_char"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">each_char  {|char| block }  &rarr; ARGF</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">each_char                   &rarr; an_enumerator</span>
            
          </div>
          
          
          <div>
  
            
            <p>Iterates over each character of each file in <code>ARGF</code>.</p>

<p>This method allows you to treat the files supplied on the command line as a
single file consisting of the concatenation of each named file. After the
last character of the first file has been returned, the first character of
the second file is returned. The <code>ARGF.filename</code> method can be
used to determine the name of the file in which the current character
appears.</p>

<p>If no block is given, an enumerator is returned instead.</p>
            

            
            <div class="method-source-code" id="each_char-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
argf_each_char(VALUE argf)
{
    RETURN_ENUMERATOR(argf, 0, 0);
    for (;;) {
        if (!next_argv()) return argf;
        rb_block_call(ARGF.current_file, rb_intern(&quot;each_char&quot;), 0, 0, 0, 0);
        ARGF.next_p = 1;
    }
}
            </pre> 
            </div><!-- each_char-source -->
            
          </div>

          

          
        </div><!-- each_char-method -->
      
        <div id="each_codepoint-method" class="method-detail ">
          <a name="method-i-each_codepoint"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">each_codepoint  {|codepoint| block }  &rarr; ARGF</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">each_codepoint                   &rarr; an_enumerator</span>
            
          </div>
          
          
          <div>
  
            
            <p>Iterates over each codepoint of each file in <code>ARGF</code>.</p>

<p>This method allows you to treat the files supplied on the command line as a
single file consisting of the concatenation of each named file. After the
last codepoint of the first file has been returned, the first codepoint of
the second file is returned. The <code>ARGF.filename</code> method can be
used to determine the name of the file in which the current codepoint
appears.</p>

<p>If no block is given, an enumerator is returned instead.</p>
            

            
            <div class="method-source-code" id="each_codepoint-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
argf_each_codepoint(VALUE argf)
{
    RETURN_ENUMERATOR(argf, 0, 0);
    for (;;) {
        if (!next_argv()) return argf;
        rb_block_call(ARGF.current_file, rb_intern(&quot;each_codepoint&quot;), 0, 0, 0, 0);
        ARGF.next_p = 1;
    }
}
            </pre> 
            </div><!-- each_codepoint-source -->
            
          </div>

          

          
        </div><!-- each_codepoint-method -->
      
        <div id="each_line-method" class="method-detail ">
          <a name="method-i-each_line"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">each_line(sep=$/)       {|line| block }  &rarr; ARGF</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">each_line(sep=$/,limit) {|line| block }  &rarr; ARGF</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">each_line(...)                           &rarr; an_enumerator</span>
            
          </div>
          
          
          <div>
  
            
            <p>Returns an enumerator which iterates over each line (separated by
<em>sep</em>, which defaults to your platform’s newline character) of each
file in <code>ARGV</code>. If a block is supplied, each line in turn will
be yielded to the block, otherwise an enumerator is returned. The optional
<em>limit</em> argument is a <code>Fixnum</code> specifying the maximum
length of each line; longer lines will be split according to this limit.</p>

<p>This method allows you to treat the files supplied on the command line as a
single file consisting of the concatenation of each named file. After the
last line of the first file has been returned, the first line of the second
file is returned. The <code>ARGF.filename</code> and
<code>ARGF.lineno</code> methods can be used to determine the filename and
line number, respectively, of the current line.</p>

<p>For example, the following code prints out each line of each named file
prefixed with its line number, displaying the filename once per file:</p>

<pre class="ruby"><span class="ruby-constant">ARGF</span>.<span class="ruby-identifier">lines</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">line</span><span class="ruby-operator">|</span>
  <span class="ruby-identifier">puts</span> <span class="ruby-constant">ARGF</span>.<span class="ruby-identifier">filename</span> <span class="ruby-keyword">if</span> <span class="ruby-constant">ARGF</span>.<span class="ruby-identifier">lineno</span> <span class="ruby-operator">==</span> <span class="ruby-value">1</span>
  <span class="ruby-identifier">puts</span> <span class="ruby-node">&quot;#{ARGF.lineno}: #{line}&quot;</span>
<span class="ruby-keyword">end</span>
</pre>
            

            
            <div class="method-source-code" id="each_line-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
argf_each_line(int argc, VALUE *argv, VALUE argf)
{
    RETURN_ENUMERATOR(argf, argc, argv);
    for (;;) {
        if (!next_argv()) return argf;
        rb_block_call(ARGF.current_file, rb_intern(&quot;each_line&quot;), argc, argv, 0, 0);
        ARGF.next_p = 1;
    }
}
            </pre> 
            </div><!-- each_line-source -->
            
          </div>

          

          
        </div><!-- each_line-method -->
      
        <div id="eof-method" class="method-detail ">
          <a name="method-i-eof"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">eof?  &rarr; true or false</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">eof   &rarr; true or false</span>
            
          </div>
          
          
          <div>
  
            
            <p>Returns true if the current file in <code>ARGF</code> is at end of file,
i.e. it has no data to read. The stream must be opened for reading or an
<code>IOError</code> will be raised.</p>

<pre class="ruby">$ <span class="ruby-identifier">echo</span> <span class="ruby-string">&quot;eof&quot;</span> <span class="ruby-operator">|</span> <span class="ruby-identifier">ruby</span> <span class="ruby-identifier">argf</span>.<span class="ruby-identifier">rb</span>

<span class="ruby-constant">ARGF</span>.<span class="ruby-identifier">eof?</span>                 <span class="ruby-comment">#=&gt; false</span>
<span class="ruby-value">3</span>.<span class="ruby-identifier">times</span> { <span class="ruby-constant">ARGF</span>.<span class="ruby-identifier">readchar</span> }
<span class="ruby-constant">ARGF</span>.<span class="ruby-identifier">eof?</span>                 <span class="ruby-comment">#=&gt; false</span>
<span class="ruby-constant">ARGF</span>.<span class="ruby-identifier">readchar</span>             <span class="ruby-comment">#=&gt; &quot;\n&quot;</span>
<span class="ruby-constant">ARGF</span>.<span class="ruby-identifier">eof?</span>                 <span class="ruby-comment">#=&gt; true</span>
</pre>
            

            
            <div class="method-source-code" id="eof-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
argf_eof(VALUE argf)
{
    next_argv();
    if (RTEST(ARGF.current_file)) {
        if (ARGF.init_p == 0) return Qtrue;
        next_argv();
        ARGF_FORWARD(0, 0);
        if (rb_io_eof(ARGF.current_file)) {
            return Qtrue;
        }
    }
    return Qfalse;
}
            </pre> 
            </div><!-- eof-source -->
            
          </div>

          

          
        </div><!-- eof-method -->
      
        <div id="eof-3F-method" class="method-detail ">
          <a name="method-i-eof-3F"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">eof?  &rarr; true or false</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Returns true if the current file in <code>ARGF</code> is at end of file,
i.e. it has no data to read. The stream must be opened for reading or an
<code>IOError</code> will be raised.</p>

<pre class="ruby">$ <span class="ruby-identifier">echo</span> <span class="ruby-string">&quot;eof&quot;</span> <span class="ruby-operator">|</span> <span class="ruby-identifier">ruby</span> <span class="ruby-identifier">argf</span>.<span class="ruby-identifier">rb</span>

<span class="ruby-constant">ARGF</span>.<span class="ruby-identifier">eof?</span>                 <span class="ruby-comment">#=&gt; false</span>
<span class="ruby-value">3</span>.<span class="ruby-identifier">times</span> { <span class="ruby-constant">ARGF</span>.<span class="ruby-identifier">readchar</span> }
<span class="ruby-constant">ARGF</span>.<span class="ruby-identifier">eof?</span>                 <span class="ruby-comment">#=&gt; false</span>
<span class="ruby-constant">ARGF</span>.<span class="ruby-identifier">readchar</span>             <span class="ruby-comment">#=&gt; &quot;\n&quot;</span>
<span class="ruby-constant">ARGF</span>.<span class="ruby-identifier">eof?</span>                 <span class="ruby-comment">#=&gt; true</span>
</pre>
            

            
            <div class="method-source-code" id="eof-3F-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
argf_eof(VALUE argf)
{
    next_argv();
    if (RTEST(ARGF.current_file)) {
        if (ARGF.init_p == 0) return Qtrue;
        next_argv();
        ARGF_FORWARD(0, 0);
        if (rb_io_eof(ARGF.current_file)) {
            return Qtrue;
        }
    }
    return Qfalse;
}
            </pre> 
            </div><!-- eof-3F-source -->
            
          </div>

          

          
        </div><!-- eof-3F-method -->
      
        <div id="external_encoding-method" class="method-detail ">
          <a name="method-i-external_encoding"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">external_encoding   &rarr; encoding</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <pre>Returns the external encoding for files read from +ARGF+ as an +Encoding+
object. The external encoding is the encoding of the text as stored in a
file. Contrast with +ARGF.internal_encoding+, which is the encoding used
to represent this text within Ruby.

To set the external encoding use +ARGF.set_encoding+.</pre>

<p>For example:</p>

<pre class="ruby"><span class="ruby-constant">ARGF</span>.<span class="ruby-identifier">external_encoding</span>  <span class="ruby-comment">#=&gt;  #&lt;Encoding:UTF-8&gt;</span>
</pre>
            

            
            <div class="method-source-code" id="external_encoding-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
argf_external_encoding(VALUE argf)
{
    if (!RTEST(ARGF.current_file)) {
        return rb_enc_from_encoding(rb_default_external_encoding());
    }
    return rb_io_external_encoding(rb_io_check_io(ARGF.current_file));
}
            </pre> 
            </div><!-- external_encoding-source -->
            
          </div>

          

          
        </div><!-- external_encoding-method -->
      
        <div id="file-method" class="method-detail ">
          <a name="method-i-file"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">file  &rarr; IO or File object</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Returns the current file as an <code>IO</code> or <code>File</code> object.
#&lt;IO:&lt;STDIN&gt;&gt; is returned when the current file is STDIN.</p>

<p>For example:</p>

<pre class="ruby">$ <span class="ruby-identifier">echo</span> <span class="ruby-string">&quot;foo&quot;</span> <span class="ruby-operator">&gt;</span> <span class="ruby-identifier">foo</span>
$ <span class="ruby-identifier">echo</span> <span class="ruby-string">&quot;bar&quot;</span> <span class="ruby-operator">&gt;</span> <span class="ruby-identifier">bar</span>

$ <span class="ruby-identifier">ruby</span> <span class="ruby-identifier">argf</span>.<span class="ruby-identifier">rb</span> <span class="ruby-identifier">foo</span> <span class="ruby-identifier">bar</span>

<span class="ruby-constant">ARGF</span>.<span class="ruby-identifier">file</span>      <span class="ruby-comment">#=&gt; #&lt;File:foo&gt;</span>
<span class="ruby-constant">ARGF</span>.<span class="ruby-identifier">read</span>(<span class="ruby-value">5</span>)   <span class="ruby-comment">#=&gt; &quot;foo\nb&quot;</span>
<span class="ruby-constant">ARGF</span>.<span class="ruby-identifier">file</span>      <span class="ruby-comment">#=&gt; #&lt;File:bar&gt;</span>
</pre>
            

            
            <div class="method-source-code" id="file-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
argf_file(VALUE argf)
{
    next_argv();
    return ARGF.current_file;
}
            </pre> 
            </div><!-- file-source -->
            
          </div>

          

          
        </div><!-- file-method -->
      
        <div id="filename-method" class="method-detail ">
          <a name="method-i-filename"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">filename  &rarr; String</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Returns the current filename. “-” is returned when the current file is
STDIN.</p>

<p>For example:</p>

<pre class="ruby">$ <span class="ruby-identifier">echo</span> <span class="ruby-string">&quot;foo&quot;</span> <span class="ruby-operator">&gt;</span> <span class="ruby-identifier">foo</span>
$ <span class="ruby-identifier">echo</span> <span class="ruby-string">&quot;bar&quot;</span> <span class="ruby-operator">&gt;</span> <span class="ruby-identifier">bar</span>
$ <span class="ruby-identifier">echo</span> <span class="ruby-string">&quot;glark&quot;</span> <span class="ruby-operator">&gt;</span> <span class="ruby-identifier">glark</span>

$ <span class="ruby-identifier">ruby</span> <span class="ruby-identifier">argf</span>.<span class="ruby-identifier">rb</span> <span class="ruby-identifier">foo</span> <span class="ruby-identifier">bar</span> <span class="ruby-identifier">glark</span>

<span class="ruby-constant">ARGF</span>.<span class="ruby-identifier">filename</span>  <span class="ruby-comment">#=&gt; &quot;foo&quot;</span>
<span class="ruby-constant">ARGF</span>.<span class="ruby-identifier">read</span>(<span class="ruby-value">5</span>)   <span class="ruby-comment">#=&gt; &quot;foo\nb&quot;</span>
<span class="ruby-constant">ARGF</span>.<span class="ruby-identifier">filename</span>  <span class="ruby-comment">#=&gt; &quot;bar&quot;</span>
<span class="ruby-constant">ARGF</span>.<span class="ruby-identifier">skip</span>
<span class="ruby-constant">ARGF</span>.<span class="ruby-identifier">filename</span>  <span class="ruby-comment">#=&gt; &quot;glark&quot;</span>
</pre>
            

            
            <div class="method-source-code" id="filename-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
argf_filename(VALUE argf)
{
    next_argv();
    return ARGF.filename;
}
            </pre> 
            </div><!-- filename-source -->
            
          </div>

          

          
        </div><!-- filename-method -->
      
        <div id="fileno-method" class="method-detail ">
          <a name="method-i-fileno"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">fileno    &rarr; fixnum</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Returns an integer representing the numeric file descriptor for the current
file. Raises an <code>ArgumentError</code> if there isn’t a current file.</p>

<pre class="ruby"><span class="ruby-constant">ARGF</span>.<span class="ruby-identifier">fileno</span>    <span class="ruby-comment">#=&gt; 3</span>
</pre>
            

            
            <div class="method-source-code" id="fileno-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
argf_fileno(VALUE argf)
{
    if (!next_argv()) {
        rb_raise(rb_eArgError, &quot;no stream&quot;);
    }
    ARGF_FORWARD(0, 0);
    return rb_io_fileno(ARGF.current_file);
}
            </pre> 
            </div><!-- fileno-source -->
            
          </div>

          

          
        </div><!-- fileno-method -->
      
        <div id="getbyte-method" class="method-detail ">
          <a name="method-i-getbyte"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">getbyte  &rarr; Fixnum or nil</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Gets the next 8-bit byte (0..255) from <code>ARGF</code>. Returns
<code>nil</code> if called at the end of the stream.</p>

<p>For example:</p>

<pre class="ruby">$ <span class="ruby-identifier">echo</span> <span class="ruby-string">&quot;foo&quot;</span> <span class="ruby-operator">&gt;</span> <span class="ruby-identifier">file</span>
$ <span class="ruby-identifier">ruby</span> <span class="ruby-identifier">argf</span>.<span class="ruby-identifier">rb</span> <span class="ruby-identifier">file</span>

<span class="ruby-constant">ARGF</span>.<span class="ruby-identifier">getbyte</span> <span class="ruby-comment">#=&gt; 102</span>
<span class="ruby-constant">ARGF</span>.<span class="ruby-identifier">getbyte</span> <span class="ruby-comment">#=&gt; 111</span>
<span class="ruby-constant">ARGF</span>.<span class="ruby-identifier">getbyte</span> <span class="ruby-comment">#=&gt; 111</span>
<span class="ruby-constant">ARGF</span>.<span class="ruby-identifier">getbyte</span> <span class="ruby-comment">#=&gt; 10</span>
<span class="ruby-constant">ARGF</span>.<span class="ruby-identifier">getbyte</span> <span class="ruby-comment">#=&gt; nil</span>
</pre>
            

            
            <div class="method-source-code" id="getbyte-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
argf_getbyte(VALUE argf)
{
    VALUE ch;

  retry:
    if (!next_argv()) return Qnil;
    if (TYPE(ARGF.current_file) != T_FILE) {
        ch = rb_funcall3(ARGF.current_file, rb_intern(&quot;getbyte&quot;), 0, 0);
    }
    else {
        ch = rb_io_getbyte(ARGF.current_file);
    }
    if (NIL_P(ch) &amp;&amp; ARGF.next_p != -1) {
        argf_close(ARGF.current_file);
        ARGF.next_p = 1;
        goto retry;
    }

    return ch;
}
            </pre> 
            </div><!-- getbyte-source -->
            
          </div>

          

          
        </div><!-- getbyte-method -->
      
        <div id="getc-method" class="method-detail ">
          <a name="method-i-getc"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">getc  &rarr; String or nil</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Reads the next character from <code>ARGF</code> and returns it as a
<code>String</code>. Returns <code>nil</code> at the end of the stream.</p>

<p><code>ARGF</code> treats the files named on the command line as a single
file created by concatenating their contents. After returning the last
character of the first file, it returns the first character of the second
file, and so on.</p>

<p>For example:</p>

<pre class="ruby">$ <span class="ruby-identifier">echo</span> <span class="ruby-string">&quot;foo&quot;</span> <span class="ruby-operator">&gt;</span> <span class="ruby-identifier">file</span>
$ <span class="ruby-identifier">ruby</span> <span class="ruby-identifier">argf</span>.<span class="ruby-identifier">rb</span> <span class="ruby-identifier">file</span>

<span class="ruby-constant">ARGF</span>.<span class="ruby-identifier">getc</span>  <span class="ruby-comment">#=&gt; &quot;f&quot;</span>
<span class="ruby-constant">ARGF</span>.<span class="ruby-identifier">getc</span>  <span class="ruby-comment">#=&gt; &quot;o&quot;</span>
<span class="ruby-constant">ARGF</span>.<span class="ruby-identifier">getc</span>  <span class="ruby-comment">#=&gt; &quot;o&quot;</span>
<span class="ruby-constant">ARGF</span>.<span class="ruby-identifier">getc</span>  <span class="ruby-comment">#=&gt; &quot;\n&quot;</span>
<span class="ruby-constant">ARGF</span>.<span class="ruby-identifier">getc</span>  <span class="ruby-comment">#=&gt; nil</span>
<span class="ruby-constant">ARGF</span>.<span class="ruby-identifier">getc</span>  <span class="ruby-comment">#=&gt; nil</span>
</pre>
            

            
            <div class="method-source-code" id="getc-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
argf_getc(VALUE argf)
{
    VALUE ch;

  retry:
    if (!next_argv()) return Qnil;
    if (ARGF_GENERIC_INPUT_P()) {
        ch = rb_funcall3(ARGF.current_file, rb_intern(&quot;getc&quot;), 0, 0);
    }
    else {
        ch = rb_io_getc(ARGF.current_file);
    }
    if (NIL_P(ch) &amp;&amp; ARGF.next_p != -1) {
        argf_close(ARGF.current_file);
        ARGF.next_p = 1;
        goto retry;
    }

    return ch;
}
            </pre> 
            </div><!-- getc-source -->
            
          </div>

          

          
        </div><!-- getc-method -->
      
        <div id="gets-method" class="method-detail ">
          <a name="method-i-gets"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">gets(sep=$/)     &rarr; string</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">gets(limit)      &rarr; string</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">gets(sep, limit) &rarr; string</span>
            
          </div>
          
          
          <div>
  
            
            <p>Returns the next line from the current file in <code>ARGF</code>.</p>

<p>By default lines are assumed to be separated by +$/+; to use a different
character as a separator, supply it as a <code>String</code> for the
<em>sep</em> argument.</p>

<p>The optional  <em>limit</em> argument specifies how many characters of each
line to return. By default all characters are returned.</p>
            

            
            <div class="method-source-code" id="gets-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
argf_gets(int argc, VALUE *argv, VALUE argf)
{
    VALUE line;

    line = argf_getline(argc, argv, argf);
    rb_lastline_set(line);

    return line;
}
            </pre> 
            </div><!-- gets-source -->
            
          </div>

          

          
        </div><!-- gets-method -->
      
        <div id="inplace_mode-method" class="method-detail ">
          <a name="method-i-inplace_mode"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">inplace_mode  &rarr; String</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Returns the file extension appended to the names of modified files under
inplace-edit mode. This value can be set using
<code>ARGF.inplace_mode=</code> or passing the <code>-i</code> switch to
the Ruby binary.</p>
            

            
            <div class="method-source-code" id="inplace_mode-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
argf_inplace_mode_get(VALUE argf)
{
    if (!ARGF.inplace) return Qnil;
    return rb_str_new2(ARGF.inplace);
}
            </pre> 
            </div><!-- inplace_mode-source -->
            
          </div>

          

          
        </div><!-- inplace_mode-method -->
      
        <div id="inplace_mode-3D-method" class="method-detail ">
          <a name="method-i-inplace_mode-3D"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">inplace_mode = ext  &rarr; ARGF</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <pre class="ruby"><span class="ruby-constant">Sets</span> <span class="ruby-identifier">the</span> <span class="ruby-identifier">filename</span> <span class="ruby-identifier">extension</span> <span class="ruby-keyword">for</span> <span class="ruby-identifier">inplace</span> <span class="ruby-identifier">editing</span> <span class="ruby-identifier">mode</span> <span class="ruby-identifier">to</span> <span class="ruby-identifier">the</span> <span class="ruby-identifier">given</span> <span class="ruby-constant">String</span>.
<span class="ruby-constant">Each</span> <span class="ruby-identifier">file</span> <span class="ruby-identifier">being</span> <span class="ruby-identifier">edited</span> <span class="ruby-identifier">has</span> <span class="ruby-identifier">this</span> <span class="ruby-identifier">value</span> <span class="ruby-identifier">appended</span> <span class="ruby-identifier">to</span> <span class="ruby-identifier">its</span> <span class="ruby-identifier">filename</span>. <span class="ruby-constant">The</span>
<span class="ruby-identifier">modified</span> <span class="ruby-identifier">file</span> <span class="ruby-identifier">is</span> <span class="ruby-identifier">saved</span> <span class="ruby-identifier">under</span> <span class="ruby-identifier">this</span> <span class="ruby-identifier">new</span> <span class="ruby-identifier">name</span>.

<span class="ruby-constant">For</span> <span class="ruby-identifier">example</span><span class="ruby-operator">:</span>

    $ <span class="ruby-identifier">ruby</span> <span class="ruby-identifier">argf</span>.<span class="ruby-identifier">rb</span> <span class="ruby-identifier">file</span>.<span class="ruby-identifier">txt</span>

    <span class="ruby-constant">ARGF</span>.<span class="ruby-identifier">inplace_mode</span> = <span class="ruby-string">'.bak'</span>
    <span class="ruby-constant">ARGF</span>.<span class="ruby-identifier">lines</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">line</span><span class="ruby-operator">|</span>
      <span class="ruby-identifier">print</span> <span class="ruby-identifier">line</span>.<span class="ruby-identifier">sub</span>(<span class="ruby-string">&quot;foo&quot;</span>,<span class="ruby-string">&quot;bar&quot;</span>)
    <span class="ruby-keyword">end</span>
</pre>

<p>Each line of <em>file.txt</em> has the first occurrence of “foo” replaced
with “bar”, then the new line is written out to <em>file.txt.bak</em>.</p>
            

            
            <div class="method-source-code" id="inplace_mode-3D-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
argf_inplace_mode_set(VALUE argf, VALUE val)
{
    if (rb_safe_level() &gt;= 1 &amp;&amp; OBJ_TAINTED(val))
        rb_insecure_operation();

    if (!RTEST(val)) {
        if (ARGF.inplace) free(ARGF.inplace);
        ARGF.inplace = 0;
    }
    else {
        StringValue(val);
        if (ARGF.inplace) free(ARGF.inplace);
        ARGF.inplace = 0;
        ARGF.inplace = strdup(RSTRING_PTR(val));
    }
    return argf;
}
            </pre> 
            </div><!-- inplace_mode-3D-source -->
            
          </div>

          

          
        </div><!-- inplace_mode-3D-method -->
      
        <div id="internal_encoding-method" class="method-detail ">
          <a name="method-i-internal_encoding"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">internal_encoding   &rarr; encoding</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Returns the internal encoding for strings read from <code>ARGF</code> as an
<code>Encoding</code> object.</p>

<p>If <code>ARGF.set_encoding</code> has been called with two encoding names,
the second is returned. Otherwise, if
<code>Encoding.default_external</code> has been set, that value is
returned. Failing that, if a default external encoding was specified on the
command-line, that value is used. If the encoding is unknown, nil is
returned.</p>
            

            
            <div class="method-source-code" id="internal_encoding-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
argf_internal_encoding(VALUE argf)
{
    if (!RTEST(ARGF.current_file)) {
        return rb_enc_from_encoding(rb_default_external_encoding());
    }
    return rb_io_internal_encoding(rb_io_check_io(ARGF.current_file));
}
            </pre> 
            </div><!-- internal_encoding-source -->
            
          </div>

          

          
        </div><!-- internal_encoding-method -->
      
        <div id="lineno-method" class="method-detail ">
          <a name="method-i-lineno"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">lineno &rarr; integer</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Returns the current line number of <a href="ARGF.html">ARGF</a> as a whole.
This value can be set manually with <code>ARGF.lineno=</code>.</p>

<p>For example:</p>

<pre class="ruby"><span class="ruby-constant">ARGF</span>.<span class="ruby-identifier">lineno</span>   <span class="ruby-comment">#=&gt; 0</span>
<span class="ruby-constant">ARGF</span>.<span class="ruby-identifier">readline</span> <span class="ruby-comment">#=&gt; &quot;This is line 1\n&quot;</span>
<span class="ruby-constant">ARGF</span>.<span class="ruby-identifier">lineno</span>   <span class="ruby-comment">#=&gt; 1</span>
</pre>
            

            
            <div class="method-source-code" id="lineno-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
argf_lineno(VALUE argf)
{
    return INT2FIX(ARGF.lineno);
}
            </pre> 
            </div><!-- lineno-source -->
            
          </div>

          

          
        </div><!-- lineno-method -->
      
        <div id="lineno-3D-method" class="method-detail ">
          <a name="method-i-lineno-3D"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">lineno = number  &rarr; nil</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Sets the line number of <code>ARGF</code> as a whole to the given
<code>Integer</code>.</p>

<p><code>ARGF</code> sets the line number automatically as you read data, so
normally you will not need to set it explicitly. To access the current line
number use <code>ARGF.lineno</code>.</p>

<p>For example:</p>

<pre class="ruby"><span class="ruby-constant">ARGF</span>.<span class="ruby-identifier">lineno</span>      <span class="ruby-comment">#=&gt; 0</span>
<span class="ruby-constant">ARGF</span>.<span class="ruby-identifier">readline</span>    <span class="ruby-comment">#=&gt; &quot;This is line 1\n&quot;</span>
<span class="ruby-constant">ARGF</span>.<span class="ruby-identifier">lineno</span>      <span class="ruby-comment">#=&gt; 1</span>
<span class="ruby-constant">ARGF</span>.<span class="ruby-identifier">lineno</span> = <span class="ruby-value">0</span>  <span class="ruby-comment">#=&gt; nil</span>
<span class="ruby-constant">ARGF</span>.<span class="ruby-identifier">lineno</span>      <span class="ruby-comment">#=&gt; 0</span>
</pre>
            

            
            <div class="method-source-code" id="lineno-3D-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
argf_set_lineno(VALUE argf, VALUE val)
{
    ARGF.lineno = NUM2INT(val);
    ARGF.last_lineno = ARGF.lineno;
    return Qnil;
}
            </pre> 
            </div><!-- lineno-3D-source -->
            
          </div>

          

          
        </div><!-- lineno-3D-method -->
      
        <div id="lines-method" class="method-detail ">
          <a name="method-i-lines"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">lines(sep=$/)           {|line| block }   &rarr; ARGF</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">lines(sep=$/,limit)     {|line| block }   &rarr; ARGF</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">lines(...)                                &rarr; an_enumerator</span>
            
          </div>
          
          
          <div>
  
            
            <p>Returns an enumerator which iterates over each line (separated by
<em>sep</em>, which defaults to your platform’s newline character) of each
file in <code>ARGV</code>. If a block is supplied, each line in turn will
be yielded to the block, otherwise an enumerator is returned. The optional
<em>limit</em> argument is a <code>Fixnum</code> specifying the maximum
length of each line; longer lines will be split according to this limit.</p>

<p>This method allows you to treat the files supplied on the command line as a
single file consisting of the concatenation of each named file. After the
last line of the first file has been returned, the first line of the second
file is returned. The <code>ARGF.filename</code> and
<code>ARGF.lineno</code> methods can be used to determine the filename and
line number, respectively, of the current line.</p>

<p>For example, the following code prints out each line of each named file
prefixed with its line number, displaying the filename once per file:</p>

<pre class="ruby"><span class="ruby-constant">ARGF</span>.<span class="ruby-identifier">lines</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">line</span><span class="ruby-operator">|</span>
  <span class="ruby-identifier">puts</span> <span class="ruby-constant">ARGF</span>.<span class="ruby-identifier">filename</span> <span class="ruby-keyword">if</span> <span class="ruby-constant">ARGF</span>.<span class="ruby-identifier">lineno</span> <span class="ruby-operator">==</span> <span class="ruby-value">1</span>
  <span class="ruby-identifier">puts</span> <span class="ruby-node">&quot;#{ARGF.lineno}: #{line}&quot;</span>
<span class="ruby-keyword">end</span>
</pre>
            

            
            <div class="method-source-code" id="lines-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
argf_each_line(int argc, VALUE *argv, VALUE argf)
{
    RETURN_ENUMERATOR(argf, argc, argv);
    for (;;) {
        if (!next_argv()) return argf;
        rb_block_call(ARGF.current_file, rb_intern(&quot;each_line&quot;), argc, argv, 0, 0);
        ARGF.next_p = 1;
    }
}
            </pre> 
            </div><!-- lines-source -->
            
          </div>

          

          
        </div><!-- lines-method -->
      
        <div id="path-method" class="method-detail ">
          <a name="method-i-path"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">path      &rarr; String</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Returns the current filename. “-” is returned when the current file is
STDIN.</p>

<p>For example:</p>

<pre class="ruby">$ <span class="ruby-identifier">echo</span> <span class="ruby-string">&quot;foo&quot;</span> <span class="ruby-operator">&gt;</span> <span class="ruby-identifier">foo</span>
$ <span class="ruby-identifier">echo</span> <span class="ruby-string">&quot;bar&quot;</span> <span class="ruby-operator">&gt;</span> <span class="ruby-identifier">bar</span>
$ <span class="ruby-identifier">echo</span> <span class="ruby-string">&quot;glark&quot;</span> <span class="ruby-operator">&gt;</span> <span class="ruby-identifier">glark</span>

$ <span class="ruby-identifier">ruby</span> <span class="ruby-identifier">argf</span>.<span class="ruby-identifier">rb</span> <span class="ruby-identifier">foo</span> <span class="ruby-identifier">bar</span> <span class="ruby-identifier">glark</span>

<span class="ruby-constant">ARGF</span>.<span class="ruby-identifier">filename</span>  <span class="ruby-comment">#=&gt; &quot;foo&quot;</span>
<span class="ruby-constant">ARGF</span>.<span class="ruby-identifier">read</span>(<span class="ruby-value">5</span>)   <span class="ruby-comment">#=&gt; &quot;foo\nb&quot;</span>
<span class="ruby-constant">ARGF</span>.<span class="ruby-identifier">filename</span>  <span class="ruby-comment">#=&gt; &quot;bar&quot;</span>
<span class="ruby-constant">ARGF</span>.<span class="ruby-identifier">skip</span>
<span class="ruby-constant">ARGF</span>.<span class="ruby-identifier">filename</span>  <span class="ruby-comment">#=&gt; &quot;glark&quot;</span>
</pre>
            

            
            <div class="method-source-code" id="path-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
argf_filename(VALUE argf)
{
    next_argv();
    return ARGF.filename;
}
            </pre> 
            </div><!-- path-source -->
            
          </div>

          

          
        </div><!-- path-method -->
      
        <div id="pos-method" class="method-detail ">
          <a name="method-i-pos"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">pos   &rarr; Integer</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Returns the current offset (in bytes) of the current file in
<code>ARGF</code>.</p>

<pre class="ruby"><span class="ruby-constant">ARGF</span>.<span class="ruby-identifier">pos</span>    <span class="ruby-comment">#=&gt; 0</span>
<span class="ruby-constant">ARGF</span>.<span class="ruby-identifier">gets</span>   <span class="ruby-comment">#=&gt; &quot;This is line one\n&quot;</span>
<span class="ruby-constant">ARGF</span>.<span class="ruby-identifier">pos</span>    <span class="ruby-comment">#=&gt; 17</span>
</pre>
            

            
            <div class="method-source-code" id="pos-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
argf_tell(VALUE argf)
{
    if (!next_argv()) {
        rb_raise(rb_eArgError, &quot;no stream to tell&quot;);
    }
    ARGF_FORWARD(0, 0);
    return rb_io_tell(ARGF.current_file);
}
            </pre> 
            </div><!-- pos-source -->
            
          </div>

          

          
        </div><!-- pos-method -->
      
        <div id="pos-3D-method" class="method-detail ">
          <a name="method-i-pos-3D"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">pos = position  &rarr; Integer</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Seeks to the position given by <em>position</em> (in bytes) in
<code>ARGF</code>.</p>

<p>For example:</p>

<pre class="ruby"><span class="ruby-constant">ARGF</span>.<span class="ruby-identifier">pos</span> = <span class="ruby-value">17</span>
<span class="ruby-constant">ARGF</span>.<span class="ruby-identifier">gets</span>   <span class="ruby-comment">#=&gt; &quot;This is line two\n&quot;</span>
</pre>
            

            
            <div class="method-source-code" id="pos-3D-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
argf_set_pos(VALUE argf, VALUE offset)
{
    if (!next_argv()) {
        rb_raise(rb_eArgError, &quot;no stream to set position&quot;);
    }
    ARGF_FORWARD(1, &amp;offset);
    return rb_io_set_pos(ARGF.current_file, offset);
}
            </pre> 
            </div><!-- pos-3D-source -->
            
          </div>

          

          
        </div><!-- pos-3D-method -->
      
        <div id="print-method" class="method-detail ">
          <a name="method-i-print"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">print()             &rarr; nil</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">print(obj, ...)     &rarr; nil</span>
            
          </div>
          
          
          <div>
  
            
            <p>Writes the given object(s) to <em>ios</em>. The stream must be opened for
writing. If the output field separator (<code>$,</code>) is not
<code>nil</code>, it will be inserted between each object. If the output
record separator (<code>$\&lt;/code&gt;) is not &lt;code&gt;nil</code>, it
will be appended to the output. If no arguments are given, prints
<code>$_</code>. Objects that aren’t strings will be converted by calling
their <code>to_s</code> method. With no argument, prints the contents of
the variable <code>$_</code>. Returns <code>nil</code>.</p>

<pre>$stdout.print(&quot;This is &quot;, 100, &quot; percent.\n&quot;)</pre>

<p><em>produces:</em></p>

<pre>This is 100 percent.</pre>
            

            
            <div class="method-source-code" id="print-source">
              <pre> <!-- method.markup_code 290 -->
               VALUE
rb_io_print(int argc, VALUE *argv, VALUE out)
{
    int i;
    VALUE line;

    /* if no argument given, print `$_' */
    if (argc == 0) {
        argc = 1;
        line = rb_lastline_get();
        argv = &amp;line;
    }
    for (i=0; i&lt;argc; i++) {
        if (!NIL_P(rb_output_fs) &amp;&amp; i&gt;0) {
            rb_io_write(out, rb_output_fs);
        }
        rb_io_write(out, argv[i]);
    }
    if (argc &gt; 0 &amp;&amp; !NIL_P(rb_output_rs)) {
        rb_io_write(out, rb_output_rs);
    }

    return Qnil;
}
            </pre> 
            </div><!-- print-source -->
            
          </div>

          

          
        </div><!-- print-method -->
      
        <div id="printf-method" class="method-detail ">
          <a name="method-i-printf"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">printf(format_string [, obj, ...])   &rarr; nil</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Formats and writes to <em>ios</em>, converting parameters under control of
the format string. See <code>Kernel#sprintf</code> for details.</p>
            

            
            <div class="method-source-code" id="printf-source">
              <pre> <!-- method.markup_code 290 -->
               VALUE
rb_io_printf(int argc, VALUE *argv, VALUE out)
{
    rb_io_write(out, rb_f_sprintf(argc, argv));
    return Qnil;
}
            </pre> 
            </div><!-- printf-source -->
            
          </div>

          

          
        </div><!-- printf-method -->
      
        <div id="putc-method" class="method-detail ">
          <a name="method-i-putc"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">putc(obj)    &rarr; obj</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>If <em>obj</em> is <code>Numeric</code>, write the character whose code is
the least-significant byte of <em>obj</em>, otherwise write the first byte
of the string representation of <em>obj</em> to <em>ios</em>. Note: This
method is not safe for use with multi-byte characters as it will truncate
them.</p>

<pre>$stdout.putc &quot;A&quot;
$stdout.putc 65</pre>

<p><em>produces:</em></p>

<pre>AA</pre>
            

            
            <div class="method-source-code" id="putc-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_io_putc(VALUE io, VALUE ch)
{
    VALUE str;
    if (TYPE(ch) == T_STRING) {
        str = rb_str_substr(ch, 0, 1);
    }
    else {
        char c = NUM2CHR(ch);
        str = rb_str_new(&amp;c, 1);
    }
    rb_io_write(io, str);
    return ch;
}
            </pre> 
            </div><!-- putc-source -->
            
          </div>

          

          
        </div><!-- putc-method -->
      
        <div id="puts-method" class="method-detail ">
          <a name="method-i-puts"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">puts(obj, ...)    &rarr; nil</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Writes the given objects to <em>ios</em> as with <code>IO#print</code>.
Writes a record separator (typically a newline) after any that do not
already end with a newline sequence. If called with an array argument,
writes each element on a new line. If called without arguments, outputs a
single record separator.</p>

<pre>$stdout.puts(&quot;this&quot;, &quot;is&quot;, &quot;a&quot;, &quot;test&quot;)</pre>

<p><em>produces:</em></p>

<pre>this
is
a
test</pre>
            

            
            <div class="method-source-code" id="puts-source">
              <pre> <!-- method.markup_code 290 -->
               VALUE
rb_io_puts(int argc, VALUE *argv, VALUE out)
{
    int i;
    VALUE line;

    /* if no argument given, print newline. */
    if (argc == 0) {
        rb_io_write(out, rb_default_rs);
        return Qnil;
    }
    for (i=0; i&lt;argc; i++) {
        if (TYPE(argv[i]) == T_STRING) {
            line = argv[i];
            goto string;
        }
        line = rb_check_array_type(argv[i]);
        if (!NIL_P(line)) {
            rb_exec_recursive(io_puts_ary, line, out);
            continue;
        }
        line = rb_obj_as_string(argv[i]);
      string:
        rb_io_write(out, line);
        if (RSTRING_LEN(line) == 0 ||
            !str_end_with_asciichar(line, '\n')) {
            rb_io_write(out, rb_default_rs);
        }
    }

    return Qnil;
}
            </pre> 
            </div><!-- puts-source -->
            
          </div>

          

          
        </div><!-- puts-method -->
      
        <div id="read-method" class="method-detail ">
          <a name="method-i-read"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">read([length [, buffer]])    &rarr; string, buffer, or nil</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <pre>Reads _length_ bytes from ARGF. The files named on the command line
are concatenated and treated as a single file by this method, so when
called without arguments the contents of this pseudo file are returned in
their entirety.

_length_ must be a non-negative integer or nil. If it is a positive
integer, +read+ tries to read at most _length_ bytes. It returns nil
if an EOF was encountered before anything could be read. Fewer than
_length_ bytes may be returned if an EOF is encountered during the read.

If _length_ is omitted or is _nil_, it reads until EOF. A String is
returned even if EOF is encountered before any data is read.

If _length_ is zero, it returns _&quot;&quot;_.

If the optional _buffer_ argument is present, it must reference a String,
which will receive the data.</pre>

<p>For example:</p>

<pre class="ruby">   $ <span class="ruby-identifier">echo</span> <span class="ruby-string">&quot;small&quot;</span> <span class="ruby-operator">&gt;</span> <span class="ruby-identifier">small</span>.<span class="ruby-identifier">txt</span>
   $ <span class="ruby-identifier">echo</span> <span class="ruby-string">&quot;large&quot;</span> <span class="ruby-operator">&gt;</span> <span class="ruby-identifier">large</span>.<span class="ruby-identifier">txt</span>
   $ .<span class="ruby-operator">/</span><span class="ruby-identifier">glark</span>.<span class="ruby-identifier">rb</span> <span class="ruby-identifier">small</span>.<span class="ruby-identifier">txt</span> <span class="ruby-identifier">large</span>.<span class="ruby-identifier">txt</span>

   <span class="ruby-constant">ARGF</span>.<span class="ruby-identifier">read</span>      <span class="ruby-comment">#=&gt; &quot;small\nlarge&quot;</span>
   <span class="ruby-constant">ARGF</span>.<span class="ruby-identifier">read</span>(<span class="ruby-value">200</span>) <span class="ruby-comment">#=&gt; &quot;small\nlarge&quot;</span>
   <span class="ruby-constant">ARGF</span>.<span class="ruby-identifier">read</span>(<span class="ruby-value">2</span>)   <span class="ruby-comment">#=&gt; &quot;sm&quot;</span>
   <span class="ruby-constant">ARGF</span>.<span class="ruby-identifier">read</span>(<span class="ruby-value">0</span>)   <span class="ruby-comment">#=&gt; &quot;&quot;</span>

<span class="ruby-constant">Note</span> <span class="ruby-identifier">that</span> <span class="ruby-identifier">this</span> <span class="ruby-identifier">method</span> <span class="ruby-identifier">behaves</span> <span class="ruby-identifier">like</span> <span class="ruby-identifier">fread</span>() <span class="ruby-identifier">function</span> <span class="ruby-keyword">in</span> <span class="ruby-constant">C</span>.  <span class="ruby-constant">If</span> <span class="ruby-identifier">you</span> <span class="ruby-identifier">need</span> <span class="ruby-identifier">the</span>
<span class="ruby-identifier">behavior</span> <span class="ruby-identifier">like</span> <span class="ruby-identifier">read</span>(<span class="ruby-value">2</span>) <span class="ruby-identifier">system</span> <span class="ruby-identifier">call</span>, <span class="ruby-identifier">consider</span> <span class="ruby-operator">+</span><span class="ruby-constant">ARGF</span>.<span class="ruby-identifier">readpartial</span><span class="ruby-operator">+</span>.
</pre>
            

            
            <div class="method-source-code" id="read-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
argf_read(int argc, VALUE *argv, VALUE argf)
{
    VALUE tmp, str, length;
    long len = 0;

    rb_scan_args(argc, argv, &quot;02&quot;, &amp;length, &amp;str);
    if (!NIL_P(length)) {
        len = NUM2LONG(argv[0]);
    }
    if (!NIL_P(str)) {
        StringValue(str);
        rb_str_resize(str,0);
        argv[1] = Qnil;
    }

  retry:
    if (!next_argv()) {
        return str;
    }
    if (ARGF_GENERIC_INPUT_P()) {
        tmp = argf_forward(argc, argv, argf);
    }
    else {
        tmp = io_read(argc, argv, ARGF.current_file);
    }
    if (NIL_P(str)) str = tmp;
    else if (!NIL_P(tmp)) rb_str_append(str, tmp);
    if (NIL_P(tmp) || NIL_P(length)) {
        if (ARGF.next_p != -1) {
            argf_close(ARGF.current_file);
            ARGF.next_p = 1;
            goto retry;
        }
    }
    else if (argc &gt;= 1) {
        if (RSTRING_LEN(str) &lt; len) {
            len -= RSTRING_LEN(str);
            argv[0] = INT2NUM(len);
            goto retry;
        }
    }
    return str;
}
            </pre> 
            </div><!-- read-source -->
            
          </div>

          

          
        </div><!-- read-method -->
      
        <div id="read_nonblock-method" class="method-detail ">
          <a name="method-i-read_nonblock"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">read_nonblock(maxlen)              &rarr; string</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">read_nonblock(maxlen, outbuf)      &rarr; outbuf</span>
            
          </div>
          
          
          <div>
  
            
            <p>Reads at most <em>maxlen</em> bytes from the <a href="ARGF.html">ARGF</a>
stream in non-blocking mode.</p>
            

            
            <div class="method-source-code" id="read_nonblock-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
argf_read_nonblock(int argc, VALUE *argv, VALUE argf)
{
    return argf_getpartial(argc, argv, argf, 1);
}
            </pre> 
            </div><!-- read_nonblock-source -->
            
          </div>

          

          
        </div><!-- read_nonblock-method -->
      
        <div id="readbyte-method" class="method-detail ">
          <a name="method-i-readbyte"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">readbyte  &rarr; Fixnum</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Reads the next 8-bit byte from <a href="ARGF.html">ARGF</a> and returns it
as a <code>Fixnum</code>. Raises an <code>EOFError</code> after the last
byte of the last file has been read.</p>

<p>For example:</p>

<pre class="ruby">$ <span class="ruby-identifier">echo</span> <span class="ruby-string">&quot;foo&quot;</span> <span class="ruby-operator">&gt;</span> <span class="ruby-identifier">file</span>
$ <span class="ruby-identifier">ruby</span> <span class="ruby-identifier">argf</span>.<span class="ruby-identifier">rb</span> <span class="ruby-identifier">file</span>

<span class="ruby-constant">ARGF</span>.<span class="ruby-identifier">readbyte</span>  <span class="ruby-comment">#=&gt; 102</span>
<span class="ruby-constant">ARGF</span>.<span class="ruby-identifier">readbyte</span>  <span class="ruby-comment">#=&gt; 111</span>
<span class="ruby-constant">ARGF</span>.<span class="ruby-identifier">readbyte</span>  <span class="ruby-comment">#=&gt; 111</span>
<span class="ruby-constant">ARGF</span>.<span class="ruby-identifier">readbyte</span>  <span class="ruby-comment">#=&gt; 10</span>
<span class="ruby-constant">ARGF</span>.<span class="ruby-identifier">readbyte</span>  <span class="ruby-comment">#=&gt; end of file reached (EOFError)</span>
</pre>
            

            
            <div class="method-source-code" id="readbyte-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
argf_readbyte(VALUE argf)
{
    VALUE c;

    NEXT_ARGF_FORWARD(0, 0);
    c = argf_getbyte(argf);
    if (NIL_P(c)) {
        rb_eof_error();
    }
    return c;
}
            </pre> 
            </div><!-- readbyte-source -->
            
          </div>

          

          
        </div><!-- readbyte-method -->
      
        <div id="readchar-method" class="method-detail ">
          <a name="method-i-readchar"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">readchar  &rarr; String or nil</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Reads the next character from <code>ARGF</code> and returns it as a
<code>String</code>. Raises an <code>EOFError</code> after the last
character of the last file has been read.</p>

<p>For example:</p>

<pre class="ruby">$ <span class="ruby-identifier">echo</span> <span class="ruby-string">&quot;foo&quot;</span> <span class="ruby-operator">&gt;</span> <span class="ruby-identifier">file</span>
$ <span class="ruby-identifier">ruby</span> <span class="ruby-identifier">argf</span>.<span class="ruby-identifier">rb</span> <span class="ruby-identifier">file</span>

<span class="ruby-constant">ARGF</span>.<span class="ruby-identifier">readchar</span>  <span class="ruby-comment">#=&gt; &quot;f&quot;</span>
<span class="ruby-constant">ARGF</span>.<span class="ruby-identifier">readchar</span>  <span class="ruby-comment">#=&gt; &quot;o&quot;</span>
<span class="ruby-constant">ARGF</span>.<span class="ruby-identifier">readchar</span>  <span class="ruby-comment">#=&gt; &quot;o&quot;</span>
<span class="ruby-constant">ARGF</span>.<span class="ruby-identifier">readchar</span>  <span class="ruby-comment">#=&gt; &quot;\n&quot;</span>
<span class="ruby-constant">ARGF</span>.<span class="ruby-identifier">readchar</span>  <span class="ruby-comment">#=&gt; end of file reached (EOFError)</span>
</pre>
            

            
            <div class="method-source-code" id="readchar-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
argf_readchar(VALUE argf)
{
    VALUE ch;

  retry:
    if (!next_argv()) rb_eof_error();
    if (TYPE(ARGF.current_file) != T_FILE) {
        ch = rb_funcall3(ARGF.current_file, rb_intern(&quot;getc&quot;), 0, 0);
    }
    else {
        ch = rb_io_getc(ARGF.current_file);
    }
    if (NIL_P(ch) &amp;&amp; ARGF.next_p != -1) {
        argf_close(ARGF.current_file);
        ARGF.next_p = 1;
        goto retry;
    }

    return ch;
}
            </pre> 
            </div><!-- readchar-source -->
            
          </div>

          

          
        </div><!-- readchar-method -->
      
        <div id="readline-method" class="method-detail ">
          <a name="method-i-readline"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">readline(sep=$/)     &rarr; string</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">readline(limit)      &rarr; string</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">readline(sep, limit) &rarr; string</span>
            
          </div>
          
          
          <div>
  
            
            <p>Returns the next line from the current file in <code>ARGF</code>.</p>

<p>By default lines are assumed to be separated by +$/+; to use a different
character as a separator, supply it as a <code>String</code> for the
<em>sep</em> argument.</p>

<p>The optional  <em>limit</em> argument specifies how many characters of each
line to return. By default all characters are returned.</p>

<p>An <code>EOFError</code> is raised at the end of the file.</p>
            

            
            <div class="method-source-code" id="readline-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
argf_readline(int argc, VALUE *argv, VALUE argf)
{
    VALUE line;

    if (!next_argv()) rb_eof_error();
    ARGF_FORWARD(argc, argv);
    line = argf_gets(argc, argv, argf);
    if (NIL_P(line)) {
        rb_eof_error();
    }

    return line;
}
            </pre> 
            </div><!-- readline-source -->
            
          </div>

          

          
        </div><!-- readline-method -->
      
        <div id="readlines-method" class="method-detail ">
          <a name="method-i-readlines"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">readlines(sep=$/)     &rarr; array</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">readlines(limit)      &rarr; array</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">readlines(sep, limit) &rarr; array</span>
            
          </div>
          
          
          <div>
  
            
            <p>Reads <code>ARGF</code>‘s current file in its entirety, returning an
<code>Array</code> of its lines, one line per element. Lines are assumed to
be separated by <em>sep</em>.</p>

<pre class="ruby"><span class="ruby-identifier">lines</span> = <span class="ruby-constant">ARGF</span>.<span class="ruby-identifier">readlines</span>
<span class="ruby-identifier">lines</span>[<span class="ruby-value">0</span>]                <span class="ruby-comment">#=&gt; &quot;This is line one\n&quot;</span>
</pre>
            

            
            <div class="method-source-code" id="readlines-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
argf_readlines(int argc, VALUE *argv, VALUE argf)
{
    long lineno = ARGF.lineno;
    VALUE lines, ary;

    ary = rb_ary_new();
    while (next_argv()) {
        if (ARGF_GENERIC_INPUT_P()) {
            lines = rb_funcall3(ARGF.current_file, rb_intern(&quot;readlines&quot;), argc, argv);
        }
        else {
            lines = rb_io_readlines(argc, argv, ARGF.current_file);
            argf_close(ARGF.current_file);
        }
        ARGF.next_p = 1;
        rb_ary_concat(ary, lines);
        ARGF.lineno = lineno + RARRAY_LEN(ary);
        ARGF.last_lineno = ARGF.lineno;
    }
    ARGF.init_p = 0;
    return ary;
}
            </pre> 
            </div><!-- readlines-source -->
            
          </div>

          

          
        </div><!-- readlines-method -->
      
        <div id="readpartial-method" class="method-detail ">
          <a name="method-i-readpartial"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">readpartial(maxlen)              &rarr; string</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">readpartial(maxlen, outbuf)      &rarr; outbuf</span>
            
          </div>
          
          
          <div>
  
            
            <p>Reads at most <em>maxlen</em> bytes from the <a href="ARGF.html">ARGF</a>
stream. It blocks only if <code>ARGF</code> has no data immediately
available. If the optional <em>outbuf</em> argument is present, it must
reference a <a href="String.html">String</a>, which will receive the data.
It raises <code>EOFError</code> on end of file.</p>

<p><code>readpartial</code> is designed for streams such as pipes, sockets,
and ttys. It blocks only when no data is immediately available. This means
that it blocks only when following all conditions hold:</p>
<ul><li>
<p>The byte buffer in the <code>IO</code> object is empty.</p>
</li><li>
<p>The content of the stream is empty.</p>
</li><li>
<p>The stream has not reached EOF.</p>
</li></ul>

<p>When <code>readpartial</code> blocks, it waits for data or EOF. If some
data is read, <code>readpartial</code> returns with the data. If EOF is
reached, readpartial raises an <code>EOFError</code>.</p>

<p>When <code>readpartial</code> doesn’t block, it returns or raises
immediately.  If the byte buffer is not empty, it returns the data in the
buffer. Otherwise, if the stream has some content, it returns the data in
the stream. If the stream reaches EOF an <code>EOFError</code> is raised.</p>
            

            
            <div class="method-source-code" id="readpartial-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
argf_readpartial(int argc, VALUE *argv, VALUE argf)
{
    return argf_getpartial(argc, argv, argf, 0);
}
            </pre> 
            </div><!-- readpartial-source -->
            
          </div>

          

          
        </div><!-- readpartial-method -->
      
        <div id="rewind-method" class="method-detail ">
          <a name="method-i-rewind"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">rewind   &rarr; 0</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Positions the current file to the beginning of input, resetting
<code>ARGF.lineno</code> to zero.</p>

<pre class="ruby"><span class="ruby-constant">ARGF</span>.<span class="ruby-identifier">readline</span>   <span class="ruby-comment">#=&gt; &quot;This is line one\n&quot;</span>
<span class="ruby-constant">ARGF</span>.<span class="ruby-identifier">rewind</span>     <span class="ruby-comment">#=&gt; 0</span>
<span class="ruby-constant">ARGF</span>.<span class="ruby-identifier">lineno</span>     <span class="ruby-comment">#=&gt; 0</span>
<span class="ruby-constant">ARGF</span>.<span class="ruby-identifier">readline</span>   <span class="ruby-comment">#=&gt; &quot;This is line one\n&quot;</span>
</pre>
            

            
            <div class="method-source-code" id="rewind-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
argf_rewind(VALUE argf)
{
    if (!next_argv()) {
        rb_raise(rb_eArgError, &quot;no stream to rewind&quot;);
    }
    ARGF_FORWARD(0, 0);
    return rb_io_rewind(ARGF.current_file);
}
            </pre> 
            </div><!-- rewind-source -->
            
          </div>

          

          
        </div><!-- rewind-method -->
      
        <div id="seek-method" class="method-detail ">
          <a name="method-i-seek"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">seek(amount, whence=IO::SEEK_SET)  &rarr;  0</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Seeks to offset <em>amount</em> (an <code>Integer</code>) in the
<code>ARGF</code> stream according to the value of <em>whence</em>. See
+IO#seek+ for further details.</p>
            

            
            <div class="method-source-code" id="seek-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
argf_seek_m(int argc, VALUE *argv, VALUE argf)
{
    if (!next_argv()) {
        rb_raise(rb_eArgError, &quot;no stream to seek&quot;);
    }
    ARGF_FORWARD(argc, argv);
    return rb_io_seek_m(argc, argv, ARGF.current_file);
}
            </pre> 
            </div><!-- seek-source -->
            
          </div>

          

          
        </div><!-- seek-method -->
      
        <div id="set_encoding-method" class="method-detail ">
          <a name="method-i-set_encoding"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">set_encoding(ext_enc)                &rarr; ARGF</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">set_encoding("ext_enc:int_enc")      &rarr; ARGF</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">set_encoding(ext_enc, int_enc)       &rarr; ARGF</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">set_encoding("ext_enc:int_enc", opt) &rarr; ARGF</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">set_encoding(ext_enc, int_enc, opt)  &rarr; ARGF</span>
            
          </div>
          
          
          <div>
  
            
            <p>If single argument is specified, strings read from <a
href="ARGF.html">ARGF</a> are tagged with the encoding specified.</p>

<p>If two encoding names separated by a colon are given, e.g. “ascii:utf-8”,
the read string is converted from the first encoding (external encoding) to
the second encoding (internal encoding), then tagged with the second
encoding.</p>

<p>If two arguments are specified, they must be encoding objects or encoding
names. Again, the first specifies the external encoding; the second
specifies the internal encoding.</p>

<p>If the external encoding and the internal encoding are specified, the
optional <code>Hash</code> argument can be used to adjust the conversion
process. The structure of this hash is explained in the +String#encode+
documentation.</p>

<p>For example:</p>

<pre>ARGF.set_encoding('ascii')         # Tag the input as US-ASCII text
ARGF.set_encoding(Encoding::UTF_8) # Tag the input as UTF-8 text
ARGF.set_encoding('utf-8','ascii') # Transcode the input from US-ASCII
                                   # to UTF-8.</pre>
            

            
            <div class="method-source-code" id="set_encoding-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
argf_set_encoding(int argc, VALUE *argv, VALUE argf)
{
    rb_io_t *fptr;

    if (!next_argv()) {
        rb_raise(rb_eArgError, &quot;no stream to set encoding&quot;);
    }
    rb_io_set_encoding(argc, argv, ARGF.current_file);
    GetOpenFile(ARGF.current_file, fptr);
    ARGF.encs = fptr-&gt;encs;
    return argf;
}
            </pre> 
            </div><!-- set_encoding-source -->
            
          </div>

          

          
        </div><!-- set_encoding-method -->
      
        <div id="skip-method" class="method-detail ">
          <a name="method-i-skip"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">skip  &rarr; ARGF</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <pre>Sets the current file to the next file in ARGV. If there aren't any more
files it has no effect.</pre>

<p>For example:</p>

<pre class="ruby">$ <span class="ruby-identifier">ruby</span> <span class="ruby-identifier">argf</span>.<span class="ruby-identifier">rb</span> <span class="ruby-identifier">foo</span> <span class="ruby-identifier">bar</span>
<span class="ruby-constant">ARGF</span>.<span class="ruby-identifier">filename</span>  <span class="ruby-comment">#=&gt; &quot;foo&quot;</span>
<span class="ruby-constant">ARGF</span>.<span class="ruby-identifier">skip</span>
<span class="ruby-constant">ARGF</span>.<span class="ruby-identifier">filename</span>  <span class="ruby-comment">#=&gt; &quot;bar&quot;</span>
</pre>
            

            
            <div class="method-source-code" id="skip-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
argf_skip(VALUE argf)
{
    if (ARGF.init_p &amp;&amp; ARGF.next_p == 0) {
        argf_close(ARGF.current_file);
        ARGF.next_p = 1;
    }
    return argf;
}
            </pre> 
            </div><!-- skip-source -->
            
          </div>

          

          
        </div><!-- skip-method -->
      
        <div id="tell-method" class="method-detail ">
          <a name="method-i-tell"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">tell  &rarr; Integer</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Returns the current offset (in bytes) of the current file in
<code>ARGF</code>.</p>

<pre class="ruby"><span class="ruby-constant">ARGF</span>.<span class="ruby-identifier">pos</span>    <span class="ruby-comment">#=&gt; 0</span>
<span class="ruby-constant">ARGF</span>.<span class="ruby-identifier">gets</span>   <span class="ruby-comment">#=&gt; &quot;This is line one\n&quot;</span>
<span class="ruby-constant">ARGF</span>.<span class="ruby-identifier">pos</span>    <span class="ruby-comment">#=&gt; 17</span>
</pre>
            

            
            <div class="method-source-code" id="tell-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
argf_tell(VALUE argf)
{
    if (!next_argv()) {
        rb_raise(rb_eArgError, &quot;no stream to tell&quot;);
    }
    ARGF_FORWARD(0, 0);
    return rb_io_tell(ARGF.current_file);
}
            </pre> 
            </div><!-- tell-source -->
            
          </div>

          

          
        </div><!-- tell-method -->
      
        <div id="to_a-method" class="method-detail ">
          <a name="method-i-to_a"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">to_a(sep=$/)     &rarr; array</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">to_a(limit)      &rarr; array</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">to_a(sep, limit) &rarr; array</span>
            
          </div>
          
          
          <div>
  
            
            <p>Reads <code>ARGF</code>‘s current file in its entirety, returning an
<code>Array</code> of its lines, one line per element. Lines are assumed to
be separated by <em>sep</em>.</p>

<pre class="ruby"><span class="ruby-identifier">lines</span> = <span class="ruby-constant">ARGF</span>.<span class="ruby-identifier">readlines</span>
<span class="ruby-identifier">lines</span>[<span class="ruby-value">0</span>]                <span class="ruby-comment">#=&gt; &quot;This is line one\n&quot;</span>
</pre>
            

            
            <div class="method-source-code" id="to_a-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
argf_readlines(int argc, VALUE *argv, VALUE argf)
{
    long lineno = ARGF.lineno;
    VALUE lines, ary;

    ary = rb_ary_new();
    while (next_argv()) {
        if (ARGF_GENERIC_INPUT_P()) {
            lines = rb_funcall3(ARGF.current_file, rb_intern(&quot;readlines&quot;), argc, argv);
        }
        else {
            lines = rb_io_readlines(argc, argv, ARGF.current_file);
            argf_close(ARGF.current_file);
        }
        ARGF.next_p = 1;
        rb_ary_concat(ary, lines);
        ARGF.lineno = lineno + RARRAY_LEN(ary);
        ARGF.last_lineno = ARGF.lineno;
    }
    ARGF.init_p = 0;
    return ary;
}
            </pre> 
            </div><!-- to_a-source -->
            
          </div>

          

          
        </div><!-- to_a-method -->
      
        <div id="to_i-method" class="method-detail ">
          <a name="method-i-to_i"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">to_i      &rarr; fixnum</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Returns an integer representing the numeric file descriptor for the current
file. Raises an <code>ArgumentError</code> if there isn’t a current file.</p>

<pre class="ruby"><span class="ruby-constant">ARGF</span>.<span class="ruby-identifier">fileno</span>    <span class="ruby-comment">#=&gt; 3</span>
</pre>
            

            
            <div class="method-source-code" id="to_i-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
argf_fileno(VALUE argf)
{
    if (!next_argv()) {
        rb_raise(rb_eArgError, &quot;no stream&quot;);
    }
    ARGF_FORWARD(0, 0);
    return rb_io_fileno(ARGF.current_file);
}
            </pre> 
            </div><!-- to_i-source -->
            
          </div>

          

          
        </div><!-- to_i-method -->
      
        <div id="to_io-method" class="method-detail ">
          <a name="method-i-to_io"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">to_io     &rarr; IO</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Returns an <code>IO</code> object representing the current file. This will
be a <code>File</code> object unless the current file is a stream such as
STDIN.</p>

<p>For example:</p>

<pre class="ruby"><span class="ruby-constant">ARGF</span>.<span class="ruby-identifier">to_io</span>    <span class="ruby-comment">#=&gt; #&lt;File:glark.txt&gt;</span>
<span class="ruby-constant">ARGF</span>.<span class="ruby-identifier">to_io</span>    <span class="ruby-comment">#=&gt; #&lt;IO:&lt;STDIN&gt;&gt;</span>
</pre>
            

            
            <div class="method-source-code" id="to_io-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
argf_to_io(VALUE argf)
{
    next_argv();
    ARGF_FORWARD(0, 0);
    return ARGF.current_file;
}
            </pre> 
            </div><!-- to_io-source -->
            
          </div>

          

          
        </div><!-- to_io-method -->
      
        <div id="to_s-method" class="method-detail ">
          <a name="method-i-to_s"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">to_s  &rarr; String</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Returns “ARGF”.</p>
            

            
            <div class="method-source-code" id="to_s-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
argf_to_s(VALUE argf)
{
    return rb_str_new2(&quot;ARGF&quot;);
}
            </pre> 
            </div><!-- to_s-source -->
            
          </div>

          

          
        </div><!-- to_s-method -->
      
        <div id="to_write_io-method" class="method-detail ">
          <a name="method-i-to_write_io"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">to_write_io  &rarr; io</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Returns <a href="IO.html">IO</a> instance tied to <em>ARGF</em> for writing
if inplace mode is enabled.</p>
            

            
            <div class="method-source-code" id="to_write_io-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
argf_write_io(VALUE argf)
{
    if (!RTEST(ARGF.current_file)) {
        rb_raise(rb_eIOError, &quot;not opened for writing&quot;);
    }
    return GetWriteIO(ARGF.current_file);
}
            </pre> 
            </div><!-- to_write_io-source -->
            
          </div>

          

          
        </div><!-- to_write_io-method -->
      
        <div id="write-method" class="method-detail ">
          <a name="method-i-write"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">write(string)   &rarr; integer</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Writes <em>string</em> if inplace mode.</p>
            

            
            <div class="method-source-code" id="write-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
argf_write(VALUE argf, VALUE str)
{
    return rb_io_write(argf_write_io(argf), str);
}
            </pre> 
            </div><!-- write-source -->
            
          </div>

          

          
        </div><!-- write-method -->
      
      </div><!-- public-instance-method-details -->
    
    </div><!-- 5Buntitled-5D -->
  
  <div id='tx_current_file_out not set_versioned' class='associated_wrapper'></div><script type='text/javascript'>$("#tx_current_file_out not set_versioned").load("/associated/1.9.3/current_file_out not set");</script> <div id='tx_current_file_out not set' class='associated_wrapper'></div><script type='text/javascript'>$("#tx_current_file_out not set").load("/associated/current_file_out not set");</script> 
  <!-- disqus ? -->
    <div class='info'>
  <p>Commenting is here to help enhance the documentation.  For example, code samples, or clarification of the documentation.</p>
  <p>If you have questions about Ruby or the documentation, please post to one of the <a href='http://www.ruby-lang.org/en/community/mailing-lists/'>Ruby mailing lists</a>.  You will get better, faster, help that way.</p>
  <p>If you wish to post a correction of the docs, please do so, but also <a href='http://bugs.ruby-lang.org/projects/ruby/wiki/HowtoReport' >file bug report</a> so that it can be corrected for the next release. Thank you.</p>
  <p>If you want to help improve the Ruby documentation, please see <a href='/improve-the-docs/'>Improve the docs</a>, or visit <a href='http://documenting-ruby.org/'>Documenting-ruby.org</a>.</p> 
    </div>


  </div><!-- documentation -->
  <div id='dynamic'>
  </div>
    <div id="disqus_thread"></div>
  <script type="text/javascript">
     function setDisqusUrl(){
      var _loc = window.location.href;
      disqus_url = _loc.split("?")[0];
    }

     var disqus_url;
     
    
     setDisqusUrl();
    /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
    // var disqus_shortname = 'rubydocbeta'; // required 
    var disqus_shortname = 'ruby-doc'; // required 


    /* * * DON'T EDIT BELOW THIS LINE * * */
    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = 'http://' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="http://disqus.com" class="dsq-brlink">blog comments powered by <span class="logo-disqus">Disqus</span></a>

<div class='grids wrapper' id="footer">
  <p><small>This page was generated for Ruby 1.9.3</small></p> 
  
   <p> <a href="http://www.ruby-doc.org">Ruby-doc.org</a> is provided by <a href="http://www.jamesbritt.com">James Britt</a> and <a href="http://www.neurogami.com">Neurogami</a>. <a href="http://www.neurogami.com">Maximum R+D</a>.  </p>
 
    <p><small>Generated with the <a href="http://neurogami.com/code/">Ruby-doc Rdoc Generator</a> 0.22.9</small>.</p>
  </div>
</div>
 <script type="text/javascript">
var _uacct = "UA-335317-2";
var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
</script>
<script type="text/javascript">
try{ 
var pageTracker = _gat._getTracker(_uacct);
pageTracker._trackPageview();
} catch(err) {} 
</script>

 <script type='text/javascript'>
$(document).ready(function() {
      $.ajaxSetup({ cache: false });
      $("#vulns-alert").load("/associated/vulns.html");
    });

    </script>


</body>
</html>


